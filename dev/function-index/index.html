<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function index · Seis.jl documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Seis.jl documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li class="is-active"><a class="tocitem" href>Function index</a><ul class="internal"><li><a class="tocitem" href="#Public-types-and-functions"><span>Public types and functions</span></a></li></ul></li><li><a class="tocitem" href="../internal-index/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anowacki/Seis.jl/blob/master/docs/src/function-index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-index"><a class="docs-heading-anchor" href="#Function-index">Function index</a><a id="Function-index-1"></a><a class="docs-heading-anchor-permalink" href="#Function-index" title="Permalink"></a></h1><h2 id="Public-types-and-functions"><a class="docs-heading-anchor" href="#Public-types-and-functions">Public types and functions</a><a id="Public-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Public-types-and-functions" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.Trace" href="#Seis.Trace"><code>Seis.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Trace</code></pre><p>Evenly-sampled time series recorded at a single seismic station.  The start time of the trace, in s, is in the <code>b</code> property, whilst the sampling interval, in s, is <code>delta</code>. The trace itself is accessed using the <code>trace</code> method, like <code>trace(t)</code>.</p><p>All <code>Trace</code>s are relative to the event time <code>evt.time</code> if it is defined, regardless of what the event is.  For example, <code>evt.time</code> could be the origin time of an earthquake, or a picked arrival time.</p><p>The trace then contains information about an associated <code>Event</code> in <code>evt</code> and the <code>Station</code> in <code>sta</code>.  <code>picks</code> holds a dictionary which contains pairs of pick times relative to the origin and names (which can be <code>missing</code>).  Access picks with the <code>picks</code> method, and add picks with <code>add_pick!</code>.</p><p>The <code>meta</code> <code>Dict</code> holds any other information about the trace.</p><p>If the event <code>time</code> is set, then the trace beginning time <code>b</code> is relative to this.</p><p>Find the trace start time relative to the origin time using <a href="#Seis.starttime"><code>starttime</code></a>. The absolute start time and date, if an origin time is set, is given by <a href="#Seis.startdate"><code>startdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L586-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.AbstractTrace" href="#Seis.AbstractTrace"><code>Seis.AbstractTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTrace</code></pre><p>Abstract type from which you should subtype if creating new types of traces.</p><p><strong>Interface</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The formal interface for <code>AbstractTrace</code>s is still a work in progress and may change with a minor version increment.</p></div></div><p>The following methods should be defined for all <code>AbstractTrace</code>s:</p><ul><li><code>trace(t)</code>: Return the data for the trace.</li><li><code>times(t)</code>: Return the time at each sample of <code>t</code>.</li><li><code>starttime(t)</code>: The time of the first sample.</li><li><code>nsamples(t)</code>: The number of samples in <code>t</code>.</li><li><code>Base.eltype(t)</code>: The element type of the data samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L565-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.CartTrace" href="#Seis.CartTrace"><code>Seis.CartTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CartTrace</code></pre><p>Alias for <code>Trace</code> where <code>Event</code> and <code>Station</code> coordinates are <code>Seis.Cartesian</code> rather than <code>Seis.Geographic</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L652-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.Event" href="#Seis.Event"><code>Seis.Event</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Event</code></pre><p>Type containing information about a seismic event.  Fields <code>lon</code> and <code>lat</code> are epicentral location in °; <code>dep</code> is depth below the reference (e.g., sea level) in km. <code>time</code> is a <code>Dates.DateTime</code> giving the event origin date and time, while <code>id</code> is a string holding the event identifier. <code>meta</code> is a <code>Dict</code> holding any extra information about the event.</p><p>Missing information is allowed and stored as <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L178-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.CartEvent" href="#Seis.CartEvent"><code>Seis.CartEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CartEvent{T}</code></pre><p>Alias for <code>Event{T, Cartesian{T}} where T</code>, representing an <a href="#Seis.Event"><code>Event</code></a> with Cartesian coordinates.</p><p>This type is useful for dispatch, allowing one to write methods which are only applicable when a <code>Event</code> has Cartesian coordinates.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; using Geodesy

julia&gt; Geodesy.LLA(evt::CartEvent) = LLA(evt.x, evt.y, evt.z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L234-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.Station" href="#Seis.Station"><code>Seis.Station</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Station</code></pre><p>Struct containing information about a seismic station.  Fields <code>net</code>, <code>sta</code>, <code>loc</code> and <code>cha</code> are the station, network, channel and location codes respectively, whilst <code>lon</code> and <code>lat</code> are the location in °.  Set station depth <code>dep</code> and elevation <code>elev</code> in m relative to the reference level.  The azimuth <code>azi</code> and inclination <code>inc</code> of the channel in ° are respectively measured from north to east, and downward from the vertical.  (E.g., a &quot;BHN&quot; channel typically will have a <code>azi == 0</code> and <code>inc == 90</code>.)</p><p><code>meta</code> is a <code>Dict</code> holding any extra information about the station or channel.</p><p>Missing information is allowed and stored as <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L301-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.CartStation" href="#Seis.CartStation"><code>Seis.CartStation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CartStation{T} where T</code></pre><p>Alias for <code>Station{T, Cartesian{T}} where T</code>, representing a <a href="#Seis.Station"><code>Station</code></a> with Cartesian coordinates.</p><p>This type is useful for dispatch, allowing one to write methods which are only applicable when a <code>Station</code> has Cartesian coordinates.</p><p><strong>Example</strong></p><p>Create a function which obtains the east-north-up coordinates of a <code>Station</code></p><pre><code class="nohighlight">julia&gt; using Geodesy

julia&gt; Geodesy.ENU(sta::CartStation) = ENU(sta.x, sta.y, sta.z)

julia&gt; ENU(CartStation(x=1, y=2, z=3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/types.jl#L376-L395">source</a></section></article><h3 id="Accessor-functions"><a class="docs-heading-anchor" href="#Accessor-functions">Accessor functions</a><a id="Accessor-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Accessor-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.channel_code" href="#Seis.channel_code"><code>Seis.channel_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_code(t::Trace) -&gt; code
channel_code(s::Station) -&gt; code</code></pre><p>Return the channel code for trace <code>t</code> or station <code>s</code>, in the form of <code>&quot;⟨network⟩.⟨name⟩.⟨location⟩.⟨component⟩&quot;</code>.  Missing fields are left blank. The information is taken respectively from the <code>net</code>, <code>sta</code>, <code>cha</code> and <code>loc</code> fields of the <code>Station</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/input_output.jl#L344-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.dates" href="#Seis.dates"><code>Seis.dates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dates(t) -&gt; date_range</code></pre><p>Return a <code>date_range</code> which contains the dates for each sample of <code>t</code>, so long as <code>t.evt.time</code> is defined.  If not, an error is thrown.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data();

julia&gt; dates(t)
1981-03-29T10:39:06.66:10 milliseconds:1981-03-29T10:39:16.65</code></pre><p>See also: <a href="#Seis.times"><code>times</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L28-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.enddate" href="#Seis.enddate"><code>Seis.enddate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enddate(t) -&gt; date</code></pre><p>Return the <code>date</code> of the last sample of the trace <code>t</code>.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data(); t.evt.time
1981-03-29T10:38:14

julia&gt; enddate(t)
1981-03-29T10:39:16.65</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L73-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.endtime" href="#Seis.endtime"><code>Seis.endtime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">endtime(t) -&gt; time</code></pre><p>Return the end <code>time</code> of trace <code>t</code> in seconds.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(5, 1, 3); # 3 samples at 1 Hz, starting at 5 s

julia&gt; endtime(t)
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L126-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.is_east" href="#Seis.is_east"><code>Seis.is_east</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_east(s::Station; tol) -&gt; ::Bool
is_east(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> or station <code>s</code> is horizontal and points to the east.</p><p>The azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p>See also: <a href="#Seis.is_north"><code>is_north</code></a>, <a href="#Seis.is_vertical"><code>is_vertical</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L214-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.is_north" href="#Seis.is_north"><code>Seis.is_north</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_north(s::Station{T}; tol) where T -&gt; ::Bool
is_north(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is horizontal and points to the north.</p><p>The azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p>See also: <a href="#Seis.is_east"><code>is_east</code></a>, <a href="#Seis.is_vertical"><code>is_vertical</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L233-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.is_horizontal" href="#Seis.is_horizontal"><code>Seis.is_horizontal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_horizontal(s::Station; tol)
is_horizontal(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is horizontal (i.e., its inclination is 90° from the vertical), and <code>false</code> otherwise.</p><p>The inclination of the trace is compared to the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; s = Station(azi=0, inc=90);

julia&gt; is_horizontal(s)
true

julia&gt; t = sample_data();

julia&gt; is_horizontal(t)
false

julia&gt; t.sta.inc
0.0f0</code></pre><p>See also: <a href="#Seis.is_vertical"><code>is_vertical</code></a>, <a href="#Seis.is_east"><code>is_east</code></a>, <a href="#Seis.is_north"><code>is_north</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L251-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.is_vertical" href="#Seis.is_vertical"><code>Seis.is_vertical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_vertical(s::Station{T}; tol=eps(T)) where T
is_vertical(t::AbstractTrace; tol=eps(eltype(trace(t)))) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is vertical (i.e., its inclination is 0°), and <code>false</code> otherwise.</p><p>The inclination of the trace is compared to the vertical within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; s = Station(azi=0, inc=90);

julia&gt; is_vertical(s)
false

julia&gt; t = sample_data();

julia&gt; is_vertical(t)
true</code></pre><p>See also: <a href="#Seis.is_horizontal"><code>is_horizontal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L284-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.nearest_sample" href="#Seis.nearest_sample"><code>Seis.nearest_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_sample(t::AbstractTrace, time; inside=true) -&gt; i</code></pre><p>Return the index <code>i</code> of the nearest sample of the trace <code>t</code> to <code>time</code> seconds.</p><p>If <code>inside</code> is <code>true</code> (the default), return <code>nothing</code> when <code>time</code> lies outside the trace.  Set <code>inside</code> to <code>false</code> to instead return the first or last index when <code>time</code> is outside the trace.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, rand(5)); # Trace starting at 0 s, 1 Hz sampling

julia&gt; nearest_sample(t, 2)
3

julia&gt; nearest_sample(t, -1)

julia&gt; nearest_sample(t, -1, inside=false)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L329-L350">source</a></section><section><div><pre><code class="nohighlight">nearest_sample(t::AbstractTrace, datetime::DateTime; inside=true)</code></pre><p>Form of <code>nearest_sample</code> where <code>datetime</code> is given as absolute time.</p><p>An error is thrown if no origin time is specified for <code>t.evt.time</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; using Dates: DateTime, Second

julia&gt; t = sample_data();

julia&gt; nearest_sample(t, DateTime(1981, 03, 29, 10, 39, 7))
35

julia&gt; nearest_sample(t, startdate(t) - Second(10)) # 10 s before the first sample

julia&gt; nearest_sample(t, startdate(t) -  Second(10), inside=false)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L360-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.nsamples" href="#Seis.nsamples"><code>Seis.nsamples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nsamples(t) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; data = rand(4);

julia&gt; t = Trace(0, 1, data);

julia&gt; nsamples(t)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L393-L407">source</a></section><section><div><pre><code class="nohighlight">nsamples(t, b, e) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code> between times <code>b</code> and <code>e</code> seconds.</p><p>This function only counts samples that are strictly on or later than the <code>b</code> time, and before or on the <code>e</code> time.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, 25); # 25 samples from 0s to 24 s

julia&gt; nsamples(t, 3, 4.1)
2</code></pre><p>See also: <a href="#Seis.nearest_sample"><code>nearest_sample</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L410-L428">source</a></section><section><div><pre><code class="nohighlight">nsamples(t, start::DateTime, stop::DateTime) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code> between dates <code>start</code> and <code>stop</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; using Dates

julia&gt; t = Trace(10, 1, 20); # 20 samples from 10 to 30 s

julia&gt; t.evt.time = DateTime(3000)
3000-01-01T00:00:00

julia&gt; nsamples(t, DateTime(3000), DateTime(3000) + Second(9))
0

julia&gt; nsamples(t, DateTime(3000) + Second(20), DateTime(3000) + Second(22))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L441-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.picks" href="#Seis.picks"><code>Seis.picks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">picks(t; sort=nothing) -&gt; p::Vector{Tuple{&lt;:AbstractString,&lt;:AbstractFloat}}</code></pre><p>Return a vector <code>p</code> of <code>Seis.Pick</code>s, which contain pairs of pick times and names associated with the <code>Trace</code> <code>t</code>.</p><p>This can be iterated like:</p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, rand(10));

julia&gt; add_pick!.(t, (1,2), (&quot;P&quot;,&quot;S&quot;));

julia&gt; for (time, name) in picks(t) @show time, name end
(time, name) = (1.0, &quot;P&quot;)
(time, name) = (2.0, &quot;S&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L123-L140">source</a></section><section><div><pre><code class="nohighlight">picks(t, name::AbstractString; sort=:time) -&gt; p
picks(t, pattern::Regex; sort=:time) -&gt; p</code></pre><p>Return a vector <code>p</code> of pairs of pick names and times associated with the <code>Trace</code> <code>t</code> which either are exactly <code>name</code> or match the regular expression <code>pattern</code>.</p><p>By default, picks are returned in order of increasing time.  Use <code>sort=:name</code> to sort alphanumerically by name (where unnamed picks appear first).</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, 2); t.picks.P = (1, &quot;Pn&quot;); t.picks.S = (1.8, &quot;S&quot;);

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:
  :P =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;Pn&quot;)
  :S =&gt; Seis.Pick{Float64}(time=1.8, name=&quot;S&quot;)

julia&gt; picks(t, &quot;S&quot;)
1-element Array{Seis.Pick{Float64},1}:
 Seis.Pick{Float64}(time=1.8, name=&quot;S&quot;)

julia&gt; picks(t, r&quot;^P&quot;)
1-element Array{Seis.Pick{Float64},1}:
 Seis.Pick{Float64}(time=1.0, name=&quot;Pn&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L146-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.startdate" href="#Seis.startdate"><code>Seis.startdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">startdate(t) -&gt; date</code></pre><p>Return the <code>date</code> of the first sample of the trace <code>t</code>.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data(); t.evt.time
1981-03-29T10:38:14

julia&gt; startdate(t)
1981-03-29T10:39:06.66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L53-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.starttime" href="#Seis.starttime"><code>Seis.starttime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">starttime(t) -&gt; time</code></pre><p>Return the start <code>time</code> of trace <code>t</code> in seconds.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(-3, 0.01, rand(20)) # Set start time to -3;

julia&gt; starttime(t)
-3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.times" href="#Seis.times"><code>Seis.times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">times(t) -&gt; range</code></pre><p>Return the set of times <code>range</code> at which each sample of the trace <code>t</code> is defined.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data();

julia&gt; times(t)
52.66f0:0.01f0:62.65f0</code></pre><p>See also: <a href="#Seis.dates"><code>dates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L474-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.trace" href="#Seis.trace"><code>Seis.trace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trace(t) -&gt; data</code></pre><p>Return an array <code>data</code> containing the values of the <code>Trace</code> <code>t</code> at each sampling point.  <code>data</code> is now a variable bound to <code>t</code>s values, and changing <code>data</code> will change <code>t</code>.  <code>trace(t)</code> may itself also be modified and the trace will be updated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The value returned by <code>trace</code> is a variable bound to an internal field of the trace.  Therefore, assigning another value to <code>trace(t)</code> or <code>data</code> will <strong>not</strong> update the values in <code>t</code>.  Instead, update the values in-place using the <code>.</code> operator (like <code>data .= 1</code>).  See examples below.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The underlying data array holding the trace can be rebound by assigning to the trace&#39;s field <code>t</code>, but this is unsupported and may break in future.</p></div></div><p><strong>Examples</strong></p><p>Retrieving the data values for a trace, and modifying the first value.</p><pre><code class="nohighlight">julia&gt; t = sample_data();

julia&gt; data = trace(t)
1000-element Array{Float32,1}:
 -0.09728001
 -0.09728001
  ⋮
 -0.0768
 -0.0768

julia&gt; data[1] = 0;

julia&gt; trace(t)
1000-element Array{Float32,1}:
  0.0
 -0.09728001
  ⋮
 -0.0768
 -0.0768</code></pre><p>Setting the data values for a new synthetic trace.</p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.01, 1000); # 1000-point, 100 Hz trace with random data

julia&gt; trace(t) .= sin.(π.*times(t));

julia&gt; trace(t)
1000-element Array{Float64,1}:
  0.0
  0.03141075907812829
  ⋮
 -0.06279051952931425
 -0.031410759078131116</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L491-L548">source</a></section></article><h3 id="Setter-functions"><a class="docs-heading-anchor" href="#Setter-functions">Setter functions</a><a id="Setter-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Setter-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.add_pick!" href="#Seis.add_pick!"><code>Seis.add_pick!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_pick!(t, time [, name=missing]) -&gt; (time, name)</code></pre><p>Add an arrival time pick to the Trace <code>t</code>, ensuring existing picks are not overwritten.</p><p>If <code>name</code> is not <code>missing</code>, then the key of this pick will be <code>Symbol(name)</code>, unless another pick with the same key already exists.  In that case, the name will be appended with a number which increases until an available key is found.</p><p>If <code>name</code> is missing, then the pick is added to a numbered set of picks.</p><p>(Direct manipulation of picks is easy: just do <code>t.picks.PKP = (1001, &quot;PKP&quot;)</code> to set a picks with name &quot;PKP&quot;, time 1001 s and key <code>:PKP</code>.)</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, 2);

julia&gt; add_pick!.(t, [1, 2], [&quot;A&quot;, missing]);

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:
  :A =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)
  1  =&gt; Seis.Pick{Float64}(time=2.0, name=missing)

julia&gt; add_pick!(t, 4)
Seis.Pick{Float64}(time=4.0, name=missing)

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 3 entries:
  :A =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)
  2  =&gt; Seis.Pick{Float64}(time=4.0, name=missing)
  1  =&gt; Seis.Pick{Float64}(time=2.0, name=missing)

julia&gt; t.picks.A
Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)

julia&gt; t.picks[1]
Seis.Pick{Float64}(time=2.0, name=missing)</code></pre><p>See also: <a href="../internal-index/#Seis.Pick"><code>Seis.Pick</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L3-L47">source</a></section><section><div><pre><code class="nohighlight">add_pick!(t, p::Pick, name=p.name) -&gt; p</code></pre><p>Add a travel time pick to the <code>Trace</code> <code>t</code> from a <code>Seis.Pick</code>.  By default, the pick name is used.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t1 = Trace(0, 1, 20); t2 = sample_data();

julia&gt; add_pick!(t1, t2.picks.A, &quot;A&quot;)
Seis.Pick{Float64}(time=53.67000198364258, name=&quot;A&quot;)

julia&gt; t1.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 1 entry:
  :A =&gt; Seis.Pick{Float64}(time=53.67000198364258, name=&quot;A&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L69-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.add_picks!" href="#Seis.add_picks!"><code>Seis.add_picks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_picks!</code></pre><p>Add picks to traces based on seismic phases&#39; predicted arrival time.</p><p>Seis does not itself implement seismic phase travel time computation. See <a href="https://github.com/anowacki/SeisTau.jl">SeisTau</a> for one implementation which adds methods to <code>add_pick!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.clear_picks!" href="#Seis.clear_picks!"><code>Seis.clear_picks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clear_picks!(t)</code></pre><p>Remove all picks associated with the <code>Trace</code> <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data();

julia&gt; picks(t)
2-element Array{Seis.Pick{Float32},1}:
 Seis.Pick{Float32}(time=53.670002, name=missing)
 Seis.Pick{Float32}(time=60.980003, name=missing)

julia&gt; clear_picks!(t);

julia&gt; picks(t)
0-element Array{Seis.Pick{Float32},1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/traveltimes.jl#L101-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.origin_time!" href="#Seis.origin_time!"><code>Seis.origin_time!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">origin_time!(t, time::DateTime; picks=true) -&gt; t</code></pre><p>Set the origin time of the trace <code>t</code> and shift the start time of the trace (stored in its <code>.b</code> field) so that the absolute time of all samples remains the same.</p><p><code>origin_time!</code> will also shift all pick times so that they remain at the same absolute time.  Set <code>picks=false</code> to leave picks at the same time relative to the trace start time.</p><p>If <code>t.evt.time</code> is <code>missing</code> (i.e., unset), then it is simply set to <code>time</code> and no times are shifted.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; using Dates

julia&gt; t = sample_data(); t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:
  :F =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)

julia&gt; t.evt.time
1981-03-29T10:38:14

julia&gt; origin_time!(t, t.evt.time + Second(1)); t.evt.time
1981-03-29T10:38:15

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:
  :F =&gt; Seis.Pick{Float32}(time=59.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=52.670002, name=missing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L141-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.origin_time" href="#Seis.origin_time"><code>Seis.origin_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">origin_time(t, time::DateTime; picks=true) -&gt; t′</code></pre><p>Return a copy to <code>t</code> where the event origin time is shifted to <code>time</code>.</p><p>See the in-place version <a href="#Seis.origin_time!"><code>origin_time!</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/util.jl#L194-L200">source</a></section></article><h3 id="Geometry-functions"><a class="docs-heading-anchor" href="#Geometry-functions">Geometry functions</a><a id="Geometry-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.azimuth" href="#Seis.azimuth"><code>Seis.azimuth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">azimuth(trace; sphere=false, flattening=Geodesics.F_WGS84) -&gt; az
azimuth(event, station; sphere=false, flattening=Geodesics.F_WGS84) -&gt; az</code></pre><p>Return the azimuth <code>az</code> from the event to the station (a seismic station) in degrees east from local north at the event for a <code>trace</code>.  Alternatively specify the <code>event</code> and <code>station</code> individually.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.backazimuth" href="#Seis.backazimuth"><code>Seis.backazimuth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">backazimuth(trace; flattening=0.0033528106718309896) -&gt; baz
backazimuth(station, event; flattening=0.0033528106718309896) -&gt; baz</code></pre><p>Return the backazimuth <code>baz</code> from the station (a seismic station) to an event in degrees east from local north at the station for a <code>trace</code>.  Alternatively specify the <code>station</code> and <code>event</code> individually.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.distance_deg" href="#Seis.distance_deg"><code>Seis.distance_deg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance_deg(trace; sphere=false, flattening=0.0033528106718309896) -&gt; Δ
distance_deg(station, event; sphere=false, flattening=0.0033528106718309896) -&gt; Δ
distance_deg(event, station; sphere=false, flattening=0.0033528106718309896) -&gt; Δ</code></pre><p>For a <code>trace</code> or an <code>event</code>-<code>station</code> pair, return the epicentral angular distance <code>Δ</code> in degrees.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.distance_direct" href="#Seis.distance_direct"><code>Seis.distance_direct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance_direct(trace)
distance_direct(event, station)
distance_direct(station, event)</code></pre><p>For a cartesian <code>trace</code> or <code>event</code>-<code>station</code> pair, return the straight-line distance between them in <strong><code>m</code></strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.distance_km" href="#Seis.distance_km"><code>Seis.distance_km</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance_km(event, station; sphere=false, a=6378.137, flattening=0.0033528106718309896) -&gt; d</code></pre><p>For a geographic <code>trace</code> or <code>event</code>–<code>station</code> pair, return the epicentral surface distance <code>d</code> in km between them.</p><p>Optionally specify the semimajor radius <code>a</code> in km and <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.    If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L100-L110">source</a></section><section><div><pre><code class="nohighlight">distance_km(event, station) -&gt; d</code></pre><p>For a cartesian <code>trace</code> or <code>event</code>-<code>station</code> pair, return the epicentral distance in km between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.incidence" href="#Seis.incidence"><code>Seis.incidence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">incidence(event, station) -&gt; i
incidence(trace) -&gt; i</code></pre><p>Return the angle of incidence <code>i</code>° between a cartesian <code>event</code> and <code>station</code>, or a cartesian <code>trace</code>.  The angle of incidence is defined downwards from the positive z (upward) direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/geometry.jl#L50-L57">source</a></section></article><h3 id="Trace-operations"><a class="docs-heading-anchor" href="#Trace-operations">Trace operations</a><a id="Trace-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.cut!" href="#Seis.cut!"><code>Seis.cut!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cut!(t, start, end; allowempty=false, warn=true) -&gt; t</code></pre><p>Cut a <code>Trace</code> <code>t</code> in place between <code>start</code> and <code>end</code>.  An error is thrown if either <code>start</code> or <code>end</code> are <code>missing</code>.</p><p>An error is thrown if the trace would be empty because either the end cut time is before the start of the trace, or the start cut is after the end, unless <code>allowempty</code> is <code>true</code>.</p><p>By default, a warning is shown if cut times lie outside the trace; set <code>warn</code> to <code>false</code> to turn this off.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 1, 2, 3, 4, 5]);

julia&gt; trace(cut!(t, 2, 4))
3-element Array{Float64,1}:
 2.0
 3.0
 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L3-L26">source</a></section><section><div><pre><code class="nohighlight">cut!(t, start_date, end_date; kwargs...) -&gt; t</code></pre><p>Cut a <code>Trace</code> <code>t</code> in place between dates <code>start_date</code> and <code>end_date</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L56-L60">source</a></section><section><div><pre><code class="nohighlight">cut!(t, pick1, offset1, pick2, offset; kwargs...) -&gt; t
cut!(t, pick, offset1, offset2; kwargs...) -&gt;</code></pre><p>Cut a trace <code>t</code> in place between <code>offset1</code> s after the first pick <code>pick1</code> and <code>offset2</code> s after <code>pick2</code>.</p><p>In the second form, both offsets are relative to <code>pick</code>.</p><p>The values of <code>pick1</code>, <code>pick2</code> and <code>pick</code> are passed to <a href="#Seis.picks"><code>picks</code></a> and so may be a <code>Symbol</code> (giving the key of the pick), a <code>String</code> (giving the pick name) or a <code>Regex</code> (which matches the pick name).</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = sample_data();

julia&gt; starttime(t), endtime(t)
(52.66f0, 62.65f0)

julia&gt; cut!(t, :A, 0, :F, 1);

julia&gt; starttime(t), endtime(t)
(53.67f0, 61.979996f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L65-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.cut" href="#Seis.cut"><code>Seis.cut</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cut(t, start, end; kwargs...) -&gt; t′
cut(t, start_date, end_date; kwargs...) -&gt; t′
cut(t, pick1, offset1, pick2, offset2; kwargs...) -&gt; t′
cut(t, pick, offset1, offset2; kwargs...) -&gt; t′</code></pre><p>Return a copy of the trace <code>t</code> cut between <code>start</code> and <code>end</code> s relative to the event origin.  You may also specify a <code>start_date</code> and <code>end_date</code>, or choose times <code>offset1</code> and <code>offset2</code> s relative to <code>pick1</code> and <code>pick2</code> respectively.  Both offset times may also be specified relative to one <code>pick</code>.</p><p>See also: <a href="#Seis.cut!"><code>cut!</code></a>, <a href="#Seis.picks"><code>picks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L103-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.decimate!" href="#Seis.decimate!"><code>Seis.decimate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decimate!(t, n; antialias=true) -&gt; t
decimate(t, n; antialias=true) -&gt; t′</code></pre><p>Decimate the trace <code>t</code> by removing all except every <code>n</code> points.  The sampling interval is increased <code>n</code> times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>By default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.</p><p>If <code>antialias</code> is <code>false</code>, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.decimate" href="#Seis.decimate"><code>Seis.decimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decimate!(t, n; antialias=true) -&gt; t
decimate(t, n; antialias=true) -&gt; t′</code></pre><p>Decimate the trace <code>t</code> by removing all except every <code>n</code> points.  The sampling interval is increased <code>n</code> times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>By default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.</p><p>If <code>antialias</code> is <code>false</code>, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.differentiate!" href="#Seis.differentiate!"><code>Seis.differentiate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">differentiate!(t::Trace; points=2) -&gt; t
differentiate(t::Trace; points=2) -&gt; t′</code></pre><p>Differentiate the trace <code>t</code> by performing <code>points</code>-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Available algorithms</strong></p><ul><li><code>points == 2</code>: Two-point.  <code>dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta</code>. Non-central difference, so <code>t.b</code> is increased by half <code>t.delta</code>. The trace length is reduced by 1 samples.</li><li><code>points == 3</code>: Three-point. <code>dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta)</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; the trace length is reduced by 2 samples.</li><li><code>points == 5</code>: Five-point. <code>dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta</code>. Central difference.  <code>t.b</code> is increased by <code>2t.delta</code>; <code>npts</code> reduced by 4.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 1, -1, 0]);

julia&gt; d = differentiate(t); trace(d)
3-element Array{Float64,1}:
  1.0
 -2.0
  1.0

julia&gt; starttime(d)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L146-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.differentiate" href="#Seis.differentiate"><code>Seis.differentiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">differentiate!(t::Trace; points=2) -&gt; t
differentiate(t::Trace; points=2) -&gt; t′</code></pre><p>Differentiate the trace <code>t</code> by performing <code>points</code>-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Available algorithms</strong></p><ul><li><code>points == 2</code>: Two-point.  <code>dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta</code>. Non-central difference, so <code>t.b</code> is increased by half <code>t.delta</code>. The trace length is reduced by 1 samples.</li><li><code>points == 3</code>: Three-point. <code>dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta)</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; the trace length is reduced by 2 samples.</li><li><code>points == 5</code>: Five-point. <code>dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta</code>. Central difference.  <code>t.b</code> is increased by <code>2t.delta</code>; <code>npts</code> reduced by 4.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 1, -1, 0]);

julia&gt; d = differentiate(t); trace(d)
3-element Array{Float64,1}:
  1.0
 -2.0
  1.0

julia&gt; starttime(d)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.envelope!" href="#Seis.envelope!"><code>Seis.envelope!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">envelope!(t::Trace) -&gt; t
envelope(t::Trace) -&gt; t′</code></pre><p>Replace the trace <code>t</code> with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);

julia&gt; trace(envelope(t))
8-element Array{Float64,1}:
 0.10355339059327379
 0.10355339059327379
 0.6035533905932737
 1.1680225577002512
 1.1680225577002512
 0.6035533905932737
 0.10355339059327373
 0.10355339059327379</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L223-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.envelope" href="#Seis.envelope"><code>Seis.envelope</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">envelope!(t::Trace) -&gt; t
envelope(t::Trace) -&gt; t′</code></pre><p>Replace the trace <code>t</code> with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);

julia&gt; trace(envelope(t))
8-element Array{Float64,1}:
 0.10355339059327379
 0.10355339059327379
 0.6035533905932737
 1.1680225577002512
 1.1680225577002512
 0.6035533905932737
 0.10355339059327373
 0.10355339059327379</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.flip!" href="#Seis.flip!"><code>Seis.flip!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flip!(t) -&gt; t
flip(t) -&gt; t′</code></pre><p>Reverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.</p><p>The <code>t.sta</code> must contain both azimuth and inclination information.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s

julia&gt; t.sta.azi, t.sta.inc = 0, 90 # North horizontal component
(0, 90)

julia&gt; flip!(t)
Seis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 1.0
 Station{Float64,Seis.Geographic{Float64}}:
      sta.cha: 180.0
      sta.azi: 180.0
      sta.inc: 90.0
     sta.meta: Seis.SeisDict{Symbol,Any}()
 Event{Float64,Seis.Geographic{Float64}}:
     evt.meta: Seis.SeisDict{Symbol,Any}()
 Trace:
        picks: 0
         meta: 

julia&gt; trace(t)
3-element Array{Float64,1}:
 -0.0
 -1.0
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L254-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.flip" href="#Seis.flip"><code>Seis.flip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flip!(t) -&gt; t
flip(t) -&gt; t′</code></pre><p>Reverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.</p><p>The <code>t.sta</code> must contain both azimuth and inclination information.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s

julia&gt; t.sta.azi, t.sta.inc = 0, 90 # North horizontal component
(0, 90)

julia&gt; flip!(t)
Seis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 1.0
 Station{Float64,Seis.Geographic{Float64}}:
      sta.cha: 180.0
      sta.azi: 180.0
      sta.inc: 90.0
     sta.meta: Seis.SeisDict{Symbol,Any}()
 Event{Float64,Seis.Geographic{Float64}}:
     evt.meta: Seis.SeisDict{Symbol,Any}()
 Trace:
        picks: 0
         meta: 

julia&gt; trace(t)
3-element Array{Float64,1}:
 -0.0
 -1.0
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.integrate!" href="#Seis.integrate!"><code>Seis.integrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integrate!(t::Trace, method=:trapezium) -&gt; t
integrate(t::Trace, method=:trapezium) -&gt; t′</code></pre><p>Replace <code>t</code> with its time-integral.  This is done by default using the trapezium rule. Use <code>method=:rectangle</code> to use the rectangle rule.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>If <code>method==:trapezium</code> (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, 1, 1, 0]);

julia&gt; trace(integrate(t))
3-element Array{Float64,1}:
 0.05
 0.15000000000000002
 0.2

julia&gt; trace(integrate(t, :rectangle))
4-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L310-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.integrate" href="#Seis.integrate"><code>Seis.integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integrate!(t::Trace, method=:trapezium) -&gt; t
integrate(t::Trace, method=:trapezium) -&gt; t′</code></pre><p>Replace <code>t</code> with its time-integral.  This is done by default using the trapezium rule. Use <code>method=:rectangle</code> to use the rectangle rule.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>If <code>method==:trapezium</code> (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, 1, 1, 0]);

julia&gt; trace(integrate(t))
3-element Array{Float64,1}:
 0.05
 0.15000000000000002
 0.2

julia&gt; trace(integrate(t, :rectangle))
4-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.normalise!" href="#Seis.normalise!"><code>Seis.normalise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L365-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.normalise" href="#Seis.normalise"><code>Seis.normalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.remove_mean!" href="#Seis.remove_mean!"><code>Seis.remove_mean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_mean!(t::Trace) -&gt; t
remove_mean(t::Trace) -&gt; t′</code></pre><p>Remove the mean of trace <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.01, [1, 1, 3, -1]);

julia&gt; trace(remove_mean(t))
4-element Array{Float64,1}:
  0.0
  0.0
  2.0
 -2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L409-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.remove_mean" href="#Seis.remove_mean"><code>Seis.remove_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_mean!(t::Trace) -&gt; t
remove_mean(t::Trace) -&gt; t′</code></pre><p>Remove the mean of trace <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.01, [1, 1, 3, -1]);

julia&gt; trace(remove_mean(t))
4-element Array{Float64,1}:
  0.0
  0.0
  2.0
 -2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.remove_trend!" href="#Seis.remove_trend!"><code>Seis.remove_trend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_trend!(t::Trace) -&gt; t
remove_trend(t::Trace) -&gt; t′</code></pre><p>Remove the trend from <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.2, [1, 2, 3, 4]);

julia&gt; trace(remove_trend(t))
4-element Array{Float64,1}:
 -2.220446049250313e-16
  0.0
  0.0
  4.440892098500626e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L435-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.remove_trend" href="#Seis.remove_trend"><code>Seis.remove_trend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_trend!(t::Trace) -&gt; t
remove_trend(t::Trace) -&gt; t′</code></pre><p>Remove the trend from <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.2, [1, 2, 3, 4]);

julia&gt; trace(remove_trend(t))
4-element Array{Float64,1}:
 -2.220446049250313e-16
  0.0
  0.0
  4.440892098500626e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.resample!" href="#Seis.resample!"><code>Seis.resample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resample!(t::AbstractTrace; delta, n) -&gt; t
resample(t::AbstractTrace; delta, n) -&gt; t′</code></pre><p>Resample the trace <code>t</code> so that either the sampling interval becomes <code>delta</code> s, or its sampling rate is increased <code>n</code> times.  One of <code>delta</code> or <code>n</code> must be given.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy (<code>t′</code>).</p><p>The functions uses <a href="#DSP.Filters.resample"><code>DSP.resample</code></a> to perform the operation, which applies an antialias filter and &#39;additional operations&#39; to prevent aliasing and minimise other artifacts.</p><p>To perform decimation without antialiasing, use <a href="#Seis.decimate"><code>decimate</code></a> or <a href="#Seis.decimate!"><code>decimate!</code></a> with <code>antialias=false</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.5, 1:4);

julia&gt; trace(resample(t, 3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L463-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample" href="#DSP.Filters.resample"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resample!(t::AbstractTrace; delta, n) -&gt; t
resample(t::AbstractTrace; delta, n) -&gt; t′</code></pre><p>Resample the trace <code>t</code> so that either the sampling interval becomes <code>delta</code> s, or its sampling rate is increased <code>n</code> times.  One of <code>delta</code> or <code>n</code> must be given.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy (<code>t′</code>).</p><p>The functions uses <a href="#DSP.Filters.resample"><code>DSP.resample</code></a> to perform the operation, which applies an antialias filter and &#39;additional operations&#39; to prevent aliasing and minimise other artifacts.</p><p>To perform decimation without antialiasing, use <a href="#Seis.decimate"><code>decimate</code></a> or <a href="#Seis.decimate!"><code>decimate!</code></a> with <code>antialias=false</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 0.5, 1:4);

julia&gt; trace(resample(t, 3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.taper!" href="#Seis.taper!"><code>Seis.taper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">taper!(t::AbstractTrace, width=0.05, form=:hanning) -&gt; t
taper(t::AbstractTrace, width=0.05, form=:hamming) -&gt; t′</code></pre><p>Apply a symmetric taper to each end of the data in trace <code>t</code>. <code>form</code> may be one of <code>:hanning</code>, <code>:hamming</code> or <code>:cosine</code>. <code>width</code> represents the fraction (at both ends) of the trace tapered, up to 0.5.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);

julia&gt; trace(taper(t))
6-element Array{Float64,1}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L508-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.taper" href="#Seis.taper"><code>Seis.taper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">taper!(t::AbstractTrace, width=0.05, form=:hanning) -&gt; t
taper(t::AbstractTrace, width=0.05, form=:hamming) -&gt; t′</code></pre><p>Apply a symmetric taper to each end of the data in trace <code>t</code>. <code>form</code> may be one of <code>:hanning</code>, <code>:hamming</code> or <code>:cosine</code>. <code>width</code> represents the fraction (at both ends) of the trace tapered, up to 0.5.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight">julia&gt; t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);

julia&gt; trace(taper(t))
6-element Array{Float64,1}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/operations.jl#L572">source</a></section></article><h3 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.bandstop!" href="#Seis.bandstop!"><code>Seis.bandstop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
bandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a bandreject filter to the trace <code>t</code> with stop band between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L65-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.bandstop" href="#Seis.bandstop"><code>Seis.bandstop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
bandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a bandreject filter to the trace <code>t</code> with stop band between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.bandpass!" href="#Seis.bandpass!"><code>Seis.bandpass!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t
bandpass(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t′</code></pre><p>Apply a bandpass filter to the trace <code>t</code> between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.bandpass" href="#Seis.bandpass"><code>Seis.bandpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t
bandpass(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t′</code></pre><p>Apply a bandpass filter to the trace <code>t</code> between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.highpass!" href="#Seis.highpass!"><code>Seis.highpass!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
highpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a highpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L91-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.highpass" href="#Seis.highpass"><code>Seis.highpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
highpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a highpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.lowpass!" href="#Seis.lowpass!"><code>Seis.lowpass!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
lowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a lowpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L116-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.lowpass" href="#Seis.lowpass"><code>Seis.lowpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
lowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a lowpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/filtering.jl#L139">source</a></section></article><h3 id="Trace-rotation"><a class="docs-heading-anchor" href="#Trace-rotation">Trace rotation</a><a id="Trace-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-rotation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.rotate_through!" href="#Seis.rotate_through!"><code>Seis.rotate_through!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate_through!(t1::Trace, t2::Trace, phi)</code></pre><p>For two traces <code>t1</code> an <code>t2</code> which are horizontal and orthgonal, rotate them <em>clockwise</em> by <code>phi</code>° about the vertical axis.</p><p>This is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate anti-clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/rotation.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.rotate_through" href="#Seis.rotate_through"><code>Seis.rotate_through</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate_through!(t1::Trace, t2::Trace, phi)</code></pre><p>For two traces <code>t1</code> an <code>t2</code> which are horizontal and orthgonal, rotate them <em>clockwise</em> by <code>phi</code>° about the vertical axis.</p><p>This is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate anti-clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/rotation.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.rotate_to_gcp!" href="#Seis.rotate_to_gcp!"><code>Seis.rotate_to_gcp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate_to_gcp!(t1, t2; reverse=false) -&gt; t1, t2</code></pre><p>Rotate the pair of traces <code>t1</code> and <code>t2</code> in place so that t1 points along the radial direction (the backazimuth plus 180°), and <code>t2</code> is 90° clockwise from that.</p><p>If <code>reverse</code> is <code>true</code>, then <code>t2</code> is rotated to be 90° anticlockwise from <code>t1</code>, so that the polarity is reversed.</p><p>The component names of the radial and transverse traces are updated to be &#39;R&#39;, and either &#39;T&#39; or &#39;-T&#39; respectively for normal and reverse polarity, unless the component code is a valid SEED identifier which seems rotatable and matches for the traces; then the correct component name is used. (E.g., <code>&quot;BHE&quot;</code> and <code>&quot;BHN&quot;</code> become <code>&quot;BHR&quot;</code> and <code>&quot;BHT&quot;</code>.)</p><p>Traces must be orthogonal and horizontal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/rotation.jl#L37-L54">source</a></section><section><div><pre><code class="nohighlight">rotate_to_gcp!(t::AbstractArray{T); kwargs...)</code></pre><p>Rotate pairs of traces in the array <code>t</code> so they are in the order <code>[R1, T1, R2, T2, ...]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/rotation.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.rotate_to_gcp" href="#Seis.rotate_to_gcp"><code>Seis.rotate_to_gcp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate_to_gcp(t1, t2; reverse=false) -&gt; R, T
rotate_to_gcp(t::AbstractArray{&lt;:AbstractTrace}; reverse=false) -&gt; t′</code></pre><p>Copying version of <code>rotate_to_gcp!</code> which returns the radial <code>R</code> and transverse <code>T</code> traces in the first form, or pairs of radial and transverse traces in the modified array <code>t′</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/rotation.jl#L107-L114">source</a></section></article><h3 id="IO"><a class="docs-heading-anchor" href="#IO">IO</a><a id="IO-1"></a><a class="docs-heading-anchor-permalink" href="#IO" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.read_mseed" href="#Seis.read_mseed"><code>Seis.read_mseed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_mseed(file; kwargs...) -&gt; traces
read_mseed(T, file; kwargs...) -&gt; traces::Vector{T}</code></pre><p>Read a single miniseed file from disk and return a set of <code>Trace</code>s.</p><p>The <code>meta.mseed_file</code> field of each trace contains the file name. </p><p>Optionally specify the type of trace <code>T &lt;: AbstractTrace</code> to read.  By default, <code>T</code> is <code>Trace{Float32, Vector{Float32}, Geographic{Float32}}</code>, since almost all seismic data stored in Miniseed format is single-precision.</p><p><strong>Example</strong></p><p>Read a single file:</p><pre><code class="nohighlight">julia&gt; read_mseed(&quot;data.mseed&quot;)</code></pre><p>Read a single file assuming a Cartesian geometry:</p><pre><code class="nohighlight">julia&gt; read_mseed(CartTrace{Float32, Vector{Float32}}, &quot;data.mseed&quot;)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using a float type of <code>Float64</code> for <code>T</code>  (e.g., <code>Trace{Float64, Vector{Float64}, Seis.Geographic{Float32}}}</code>) will not increase the precision of data read, since the current implementation of Miniseed reading converts 64-bit data into 32-bit data.</p></div></div><p><strong>Handling gapped/overlapped data</strong></p><p>When channels containing gaps or overlaps are encountered, they are split into multiple <code>Trace</code>s as each <code>Trace</code> must be continuous and evenly sampled.  However, data quite often contain single-sample offsets which are later corrected, and so these are ignored by default.</p><p>Use the keyword arguments <code>maximum_gap</code> and <code>maximum_offset</code> to control whether or not gaps cause new traces to be created.  See below for more details.</p><p><strong>Keyword arguments</strong></p><p>The following keyword arguments can be passed to <code>read_mseed</code>:</p><ul><li><p><code>maximum_gap</code>: The maximum absolute gap length in s beyond which gaps are no longer tolerated in a single trace.  By default this is the sampling interval of the trace being read.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Set <code>maximum_gap</code> to 0 to always split miniseed files into separate traces at all gaps.</p></div></div></li><li><p><code>maximum_offset</code>: The maximum sum of all gaps beyond which gaps are no longer tolerated in a single trace.  This is calculated by simply adding all the gaps together.  By default this is the sampling interval.</p></li></ul><hr/><pre><code class="nohighlight">read_mseed([T,] data::Vector{UInt8}; kwargs...) -&gt; traces</code></pre><p>Read Miniseed <code>data</code> from memory, held as a set of bytes, optionally specifying the type <code>T</code> of traces to return.  Keyword arguments are the same as for reading from a file on disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/input_output.jl#L247-L310">source</a></section><section><div><pre><code class="nohighlight">read_mseed(pattern, dir) -&gt; ::Vector{&lt;:Trace}
read_mseed(T, pattern, dir) -&gt; Vector{T}</code></pre><p>Read all files matching <code>pattern</code> in directory <code>dir</code>.</p><p>See <code>Glob.glob</code> for details of pattern matching.</p><p>Optionally specify the type of trace <code>T &lt;: AbstractTrace</code> to read.  By default, <code>T</code> is <code>Trace{Float32, Vector{Float32}, Geographic{Float32}}</code>, since almost all seismic data stored in Miniseed format is single-precision.</p><p><strong>Example</strong></p><p>Read all files matching <code>&quot;TA.*.BHZ.mseed&quot;</code> in all directories within <code>DATA</code> which themselves match <code>&quot;Event_??&quot;</code>:</p><pre><code class="nohighlight">julia&gt; read_mseed(&quot;Event_??/TA.*.BHZ.mseed&quot;, &quot;DATA&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/input_output.jl#L314-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.read_sac" href="#Seis.read_sac"><code>Seis.read_sac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_sac(file; terse=false, header_only=true) → ::Trace</code></pre><p>Read a single evenly-sampled SAC file and return a Trace.  If <code>terse</code> is <code>true</code>, then warn when auto-byteswapping files.  To read only SAC headers from files, returning an empty trace, set <code>header_only</code> to `true.</p><hr/><pre><code class="nohighlight">read_sac(glob, dir; echo=true, header_only=false) → ::Vector{Trace}</code></pre><p>Read SAC files which match the patern <code>glob</code> in directory <code>dir</code> and return a set of <code>Traces</code>.  Add the file names to <code>t.meta.file</code>.  These are relative paths.</p><p>File names matching the pattern are shown unless <code>echo</code> is <code>false</code>.</p><hr/><p>When reading SAC files, the following conventions are observed:</p><ul><li>The event id is held in header <code>KEVNM</code></li><li>Channel ID is held in <code>KCMPNM</code></li><li>Location ID is held in <code>KHOLE</code></li><li>If <code>O</code> and the file origin time parameters are set, <code>O</code> is shifted to 0 time, and all time picks are adjusted.  This is similar to using the commands <code>ch o gmt [date]; ch allt (0 - &amp;1,o&amp;)</code> to set the origin in SAC.</li><li>Time picks are added to the <code>Trace</code> picks.</li></ul><p>SAC headers which don&#39;t directly translate to <code>Trace</code> attributes are placed in the <code>.meta</code> field and have names prefixed by <code>&quot;SAC_&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/input_output.jl#L5-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.write_sac" href="#Seis.write_sac"><code>Seis.write_sac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_sac(t, file; littleendian=false)</code></pre><p>Write the <code>Trace</code> <code>t</code> to <code>file</code> in SAC format.</p><p>Keys in the <code>t.meta</code> field which begin with <code>SAC_</code> have their values written to the corresponding SAC field (e.g., <code>t.meta.SAC_kuser0</code> is written to the <code>KUSER0</code> header).  The user is responsible for ensuring that the values corresponding to these keys can be converted to the correct header type.  Note also that <code>SAC_</code> <code>meta</code> fields override the equivalent <code>Trace</code> headers (e.g., <code>t.sta.sta</code> is equivalent to <code>SAC_kstnm</code>) and so one way to override the values in <code>Trace</code> headers is to set the <code>SAC_</code> fields. Note that the header is lowercase (i.e., <code>SAC_kstnm</code> not <code>SAC_KSTNM</code>).</p><p>Time picks with keys corresponding to SAC picks headers (<code>A</code>, <code>F</code>, and <code>T0</code> to <code>T9</code>) are transferred, but other picks are not.</p><p>If <code>t</code> is in a Cartesian reference frame (i.e., its positions are given by <code>CartEvent</code> and <code>CartStation</code>), then the Cartesian station coordinates <code>x</code>, <code>y</code> and <code>z</code> are saved respectively to headers <code>USER0</code>, <code>USER1</code> and <code>USER2</code>. Likewise, the event coordinates are saved respectively to <code>USER3</code>, <code>USER4</code> and <code>USER5</code>.  Any information in <code>meta</code> fields <code>SAC_user0</code> to <code>SAC_user5</code> will overwrite this data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The convention on how non-geographic coordinates are written in SAC headers is not part of the API and may change at any time.  Saving non-standard information in SAC headers should be done explicitly by the user if this information is important.</p></div></div><p>By default, files are written to disk in bigendian format (MacSAC or SAC/BRIS convention).  Use <code>littleendian=true</code> to write in littleendian byte order (SAC/IRIS or SAC2000 convention).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/input_output.jl#L122-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.SAC.SACTrace" href="#Seis.SAC.SACTrace"><code>Seis.SAC.SACTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SACTrace(delta, npts, b=0.) -&gt; ::SACTrace</code></pre><p>Construct a composite type holding an evenly-spaced SAC time-series trace, where the trace is accessed through the field name <code>t</code>.  Supply the constant sampling interval <code>delta</code> in seconds, and the number of points in the trace <code>t</code>.  Optionally, specify the trace start time <code>b</code> in seconds.</p><pre><code class="nohighlight">SACTrace(v::AbstractVector, delta, b=0.) -&gt; ::SACTrace</code></pre><p>Construct a <code>SACTrace</code> by supplying an array <code>v</code>, sampling interval <code>delta</code> and optionally the starting time.</p><pre><code class="nohighlight">SACTrace(d::Vector{UInt8}, file=&quot;&quot;; swap=true, terse=false, check_npts=true) -&gt; ::SACTrace</code></pre><p>Construct a SACTrace from a raw array of bytes representing some data in SAC format. If <code>swap</code> is false, then non-native-endian files are not converted.  If <code>terse</code> is true, then warnings about swapping are not written.  If <code>check_npts</code> is false, then parts of files are read without error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/io/SAC/types.jl#L39-L58">source</a></section></article><h3 id="Example-data-sets"><a class="docs-heading-anchor" href="#Example-data-sets">Example data sets</a><a id="Example-data-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Example-data-sets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Seis.sample_data" href="#Seis.sample_data"><code>Seis.sample_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_data() -&gt; ::Trace
sample_data(kind::Symbol) -&gt; ::Array{Trace}</code></pre><p>Return some sample data.</p><p>With no arguments, <code>sample</code> gives one trace from a local earthquake recorded in California.</p><p>In the second form, a set of traces is returned according to the table below:</p><table><tr><th style="text-align: left"><code>kind</code></th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>:local</code></td><td style="text-align: left">Livermore Valley, CA.  9 3-component stations</td></tr><tr><td style="text-align: left"><code>:regional</code></td><td style="text-align: left">Nevada.  4 3-component stations</td></tr><tr><td style="text-align: left"><code>:teleseism</code></td><td style="text-align: left"><strong>Mid-period</strong> recording of Eureka, CA event.  4 3-c stations</td></tr><tr><td style="text-align: left"><code>:teleseisl</code></td><td style="text-align: left"><strong>Long-period</strong> recording of Eureka, CA event.  4 3-c stations</td></tr><tr><td style="text-align: left"><code>:array</code></td><td style="text-align: left">Deep Fiji event.  60 vertical stations in the UK</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/Seis.jl/blob/17ef56ce1df54991a6fc2e73bf97bbe17aff0e4f/src/sample_data.jl#L8-L26">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting</a><a class="docs-footer-nextpage" href="../internal-index/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Friday 13 August 2021 21:29">Friday 13 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
