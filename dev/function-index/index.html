<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function index · Seis.jl documentation</title><meta name="title" content="Function index · Seis.jl documentation"/><meta property="og:title" content="Function index · Seis.jl documentation"/><meta property="twitter:title" content="Function index · Seis.jl documentation"/><meta name="description" content="Documentation for Seis.jl documentation."/><meta property="og:description" content="Documentation for Seis.jl documentation."/><meta property="twitter:description" content="Documentation for Seis.jl documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Seis.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../plotting-plots/">Plotting with Plots.jl</a></li><li><a class="tocitem" href="../plotting-makie/">Plotting with Makie.jl</a></li><li class="is-active"><a class="tocitem" href>Function index</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Accessor-functions"><span>Accessor functions</span></a></li><li><a class="tocitem" href="#Setter-functions"><span>Setter functions</span></a></li><li><a class="tocitem" href="#Geometry-functions"><span>Geometry functions</span></a></li><li><a class="tocitem" href="#Trace-operations"><span>Trace operations</span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Trace-rotation"><span>Trace rotation</span></a></li><li><a class="tocitem" href="#IO"><span>IO</span></a></li><li><a class="tocitem" href="#Example-data-sets"><span>Example data sets</span></a></li></ul></li><li><a class="tocitem" href="../internal-index/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function index</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/anowacki/Seis.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-index"><a class="docs-heading-anchor" href="#Function-index">Function index</a><a id="Function-index-1"></a><a class="docs-heading-anchor-permalink" href="#Function-index" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.Trace" href="#Seis.Trace"><code>Seis.Trace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Trace</code></pre><p>Evenly-sampled time series recorded at a single seismic station.  The start time of the trace, in s, is in the <code>b</code> property, whilst the sampling interval, in s, is <code>delta</code>. The trace itself is accessed using the <code>trace</code> method, like <code>trace(t)</code>.</p><p>All <code>Trace</code>s are relative to the event time <code>evt.time</code> if it is defined, regardless of what the event is.  For example, <code>evt.time</code> could be the origin time of an earthquake, or a picked arrival time.</p><p>The trace then contains information about an associated <code>Event</code> in <code>evt</code> and the <code>Station</code> in <code>sta</code>.  <code>picks</code> holds a dictionary which contains pairs of pick times relative to the origin and names (which can be <code>missing</code>).  Access picks with the <code>picks</code> method, and add picks with <code>add_pick!</code>.</p><p>The <code>meta</code> <code>Dict</code> holds any other information about the trace.</p><p>If the event <code>time</code> is set, then the trace beginning time <code>b</code> is relative to this.</p><p>Find the trace start time relative to the origin time using <a href="#Seis.starttime"><code>starttime</code></a>. The absolute start time and date, if an origin time is set, is given by <a href="#Seis.startdate"><code>startdate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.AbstractTrace" href="#Seis.AbstractTrace"><code>Seis.AbstractTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTrace &lt;: AbstractData</code></pre><p>Abstract type from which you should subtype if creating new types of traces. <code>AbstractTrace</code>s are time-domain recordings (or synthetics) at a single channel.</p><p><strong>Interface</strong></p><div class="admonition is-info" id="Note-2e1be0bcc9147eba"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2e1be0bcc9147eba" title="Permalink"></a></header><div class="admonition-body"><p>The formal interface for <code>AbstractTrace</code>s is still a work in progress and may change with a minor version increment.</p></div></div><p>The following methods should be defined for all <code>AbstractTrace</code>s <code>t</code>:</p><ul><li><code>trace(t)</code>: Return the data for the trace.</li><li><code>times(t)</code>: Return the time at each sample of <code>t</code>.</li><li><code>starttime(t)</code>: The time of the first sample.</li><li><code>nsamples(t)</code>: The number of samples in <code>t</code>.</li><li><code>Base.eltype(t)</code>: The element type of the data samples.</li><li><code>t.evt</code>: Return the <code>Event</code> associated with this trace.</li><li><code>t.sta</code>: Return the <code>Station</code> at which this trace was recorded.</li><li><code>t.meta</code>: Return a <code>SeisDict{Symbol,Any}</code> into which metadata may be placed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.CartTrace" href="#Seis.CartTrace"><code>Seis.CartTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartTrace</code></pre><p>Alias for <code>Trace</code> where <code>Event</code> and <code>Station</code> coordinates are <code>Seis.Cartesian</code> rather than <code>Seis.Geographic</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.Event" href="#Seis.Event"><code>Seis.Event</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Event</code></pre><p>Type containing information about a seismic event.  Fields <code>lon</code> and <code>lat</code> are epicentral location in °; <code>dep</code> is depth below the reference (e.g., sea level) in km. <code>time</code> is a <code>Dates.DateTime</code> giving the event origin date and time, while <code>id</code> is a string holding the event identifier. <code>meta</code> is a <code>Dict</code> holding any extra information about the event.</p><p>Missing information is allowed and stored as <code>missing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.CartEvent" href="#Seis.CartEvent"><code>Seis.CartEvent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartEvent{T}</code></pre><p>Alias for <code>Event{T, Cartesian{T}} where T</code>, representing an <a href="#Seis.Event"><code>Event</code></a> with Cartesian coordinates.</p><p>This type is useful for dispatch, allowing one to write methods which are only applicable when a <code>Event</code> has Cartesian coordinates.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using Geodesy

julia&gt; Geodesy.LLA(evt::CartEvent) = LLA(evt.x, evt.y, evt.z)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.FourierTrace" href="#Seis.FourierTrace"><code>Seis.FourierTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FourierTrace &lt;: AbstractFourierTrace</code></pre><p>The Fourier transform of a <a href="#Seis.Trace"><code>Trace</code></a>.</p><p><code>FourierTrace</code>s contain all the information contained in their corresponding <code>Trace</code>, but with the addition of information on the original number of samples in the time domain trace, and an element type which much be <code>Complex</code>. Therefore, the fields <code>b</code>, <code>delta</code>, <code>evt</code>, <code>sta</code>, <code>picks</code>, and <code>meta</code> are all part of the public API and can be accessed the same way as for <code>Trace</code>s.</p><p>The usual way to create <code>FourierTrace</code>s is by calling <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a> on a <code>Trace</code>. To convert back to a <code>Trace</code>, call <a href="#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>ifft</code></a>.</p><div class="admonition is-info" id="Note-8eb89f2ac8255555"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8eb89f2ac8255555" title="Permalink"></a></header><div class="admonition-body"><p><code>FourierTrace</code>s share many fields with the <code>Trace</code> they came from, including the station and event, plus picks and metadata.  These fields are <strong>not</strong> copied across, and are instead references to the same <code>Station</code>, <code>Event</code>, and so on.  Therefore, any changes to the <code>FourierTrace</code> will be reflected in the corresponding <code>Trace</code>.  To avoid this, do <code>f = fft(deepcopy(t))</code>.</p></div></div><hr/><pre><code class="nohighlight hljs">FourierTrace{T,V,P}(b, delta, nsamples, data, evt, sta, picks, meta)</code></pre><p>Create a new <code>FourierTrace</code> which corresponds to a <code>Trace</code> with start time <code>b</code> s, sampling interval <code>delta</code> s and <code>nsamples</code> data points.  <code>data</code> contains a set of Fourier coefficients, starting at 0 frequency up to the Nyquist frequency.  (The coefficient normalisation is defined to be the same as that used by FFTW.)  <code>evt</code>, <code>sta</code>, <code>picks</code> and <code>meta</code> should be taken from the original <code>Trace</code>.</p><div class="admonition is-info" id="Note-bd2a354fb2529714"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bd2a354fb2529714" title="Permalink"></a></header><div class="admonition-body"><p>One usually creates <code>FourierTrace</code>s by calling <code>fft</code> on a <code>Trace</code>. Users are advised to use the keyword constructor (below) if creating new <code>FourierTrace</code>s from scratch.</p></div></div><hr/><pre><code class="nohighlight hljs">FourierTrace(; b, delta, data, nsamples=(2*length(data) - 1), evt=Event(), sta=Station(), picks=nothing, meta=nothing)</code></pre><p>Create a <code>FourierTrace</code> directly from a set of Fourier coefficients. Users will usually construct a <code>FourierTrace</code> by calling <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a> on a <code>Trace</code> instead of using this constructor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>b</code>: The starting time in s of the original recording this frequency domain trace represents.</li><li><code>delta</code>: The original sampling interval in s of the equivalent time domain trace.</li><li><code>data</code>: An <code>AbstractArray{&lt;:Complex}</code> containing the set of Fourier coefficients for this frequency domain trace.  Note that this is a &#39;one-sided&#39; set, where the first index corresponds to 0 Hz and the final index is the Nyquist frequency.  This is because <code>Trace</code>s represent real quantities.</li><li><code>nsamples</code>: The number of time domain samples in the origin time domain trace which this frequency domain trace represents.  This allows the <code>FourierTrace</code> to be converted back to the original <code>Trace</code> with no loss of the number of points.</li><li><code>evt</code>: An <code>Event</code> which defines the source and origin time for the data. Normally this should be taken from the <code>Trace</code> being used to construct the <code>FourierTrace</code>.</li><li><code>sta</code>: A <code>Station</code> which defines the recording station for the data. Normally this should be taken from the <code>Trace</code> being used to construct the <code>FourierTrace</code>.</li></ul><hr/><p>See also: <a href="#Seis.Trace"><code>Trace</code></a>, <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a>, <a href="#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>ifft</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.AbstractFourierTrace" href="#Seis.AbstractFourierTrace"><code>Seis.AbstractFourierTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractFourierTrace &lt;: AbstractRecording</code></pre><p>Abstract type from which you should subtype if creating new types of frequency-domain traces.  Note that this is a subtype of <code>AbstractData</code>, meaning methods which work for <code>AbstractData</code> objects should work for <code>AbstractFourierTrace</code> objects too.</p><p><strong>Interface</strong></p><div class="admonition is-info" id="Note-b80668613107bc73"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b80668613107bc73" title="Permalink"></a></header><div class="admonition-body"><p>The formal interface for <code>AbstractFourierTrace</code>s is still a work in progress and may change in a minor version increment.</p></div></div><p>The following methods should be defined for all <code>AbstractFourierTrace</code>s <code>f</code>:</p><ul><li><code>trace(f)</code>: Return the data for the Fourier trace.</li><li><code>frequencies(f)</code>: Return the frequency at each point of the Fourier series.</li><li><code>times(f)</code>: Return the time at each sample of the time domain trace corresponding to <code>f</code>.</li><li><code>starttime(f)</code>: The time of the first sample of the corresponding time domain trace.</li><li><code>nsamples(f)</code>: The number of samples in the time domain trace corresponding to <code>f</code>.</li><li><code>nfrequencies(f)</code>: The number of frequencies in the Fourier trace <code>f</code>.</li><li><code>Base.eltype(f)</code>: The element type of the frequency domain data samples.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.Station" href="#Seis.Station"><code>Seis.Station</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Station</code></pre><p>Struct containing information about a seismic station.  Fields <code>net</code>, <code>sta</code>, <code>loc</code> and <code>cha</code> are the station, network, channel and location codes respectively, whilst <code>lon</code> and <code>lat</code> are the location in °.  Set station elevation <code>elev</code> in m relative to the reference level.  The azimuth <code>azi</code> and inclination <code>inc</code> of the channel in ° are respectively measured from north to east, and downward from the vertical.  (E.g., a &quot;BHN&quot; channel typically will have a <code>azi == 0</code> and <code>inc == 90</code>.)</p><p><code>meta</code> is a <code>Dict</code> holding any extra information about the station or channel, such as burial depth in m.</p><p>Missing information is allowed and stored as <code>missing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.CartStation" href="#Seis.CartStation"><code>Seis.CartStation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartStation{T} where T</code></pre><p>Alias for <code>Station{T, Cartesian{T}} where T</code>, representing a <a href="#Seis.Station"><code>Station</code></a> with Cartesian coordinates.</p><p>This type is useful for dispatch, allowing one to write methods which are only applicable when a <code>Station</code> has Cartesian coordinates.</p><p><strong>Example</strong></p><p>Create a function which obtains the east-north-up coordinates of a <code>Station</code></p><pre><code class="nohighlight hljs">julia&gt; using Geodesy

julia&gt; Geodesy.ENU(sta::CartStation) = ENU(sta.x, sta.y, sta.z)

julia&gt; ENU(CartStation(x=1, y=2, z=3))</code></pre></div></section></article><h2 id="Accessor-functions"><a class="docs-heading-anchor" href="#Accessor-functions">Accessor functions</a><a id="Accessor-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Accessor-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.are_orthogonal" href="#Seis.are_orthogonal"><code>Seis.are_orthogonal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">are_orthogonal(sta1, sta2[, sta3]; tol) -&gt; ::Bool
are_orthogonal(t1, t2[, t3]; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if <code>Station</code>s <code>sta1</code> and <code>sta2</code> are orthogonal to each other, or if <code>sta1</code>, <code>sta2</code> and <code>sta3</code> form a mutually-orthogonal set.</p><p>The comparison can also be performed on <code>Trace</code>s in the second form.</p><p>Directions are considered orthogonal if they differ from 90° by less than <code>tol</code>°, with a default value given by <a href="../internal-index/#Seis._angle_tol"><code>Seis._angle_tol</code></a>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; e, n, z = sample_data(:regional)[1:3];

julia&gt; are_orthogonal(e, n)
true

julia&gt; are_orthogonal(e, n, z)
true

julia&gt; are_orthogonal(Station(azi=0, inc=90), Station(azi=91, inc=90))
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.channel_code" href="#Seis.channel_code"><code>Seis.channel_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">channel_code(t::Trace) -&gt; code
channel_code(s::Station) -&gt; code</code></pre><p>Return the channel code for trace <code>t</code> or station <code>s</code>, in the form of <code>&quot;⟨network⟩.⟨name⟩.⟨location⟩.⟨component⟩&quot;</code>.  Missing fields are left blank. The information is taken respectively from the <code>net</code>, <code>sta</code>, <code>cha</code> and <code>loc</code> fields of the <code>Station</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.dates" href="#Seis.dates"><code>Seis.dates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dates(t) -&gt; date_range</code></pre><p>Return a <code>date_range</code> which contains the dates for each sample of <code>t</code>, so long as <code>t.evt.time</code> is defined.  If not, an error is thrown.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; dates(t)
1981-03-29T10:39:06.66:10 milliseconds:1981-03-29T10:39:16.65</code></pre><p>See also: <a href="#Seis.times"><code>times</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.enddate" href="#Seis.enddate"><code>Seis.enddate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enddate(t) -&gt; date</code></pre><p>Return the <code>date</code> of the last sample of the trace <code>t</code>.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data(); t.evt.time
1981-03-29T10:38:14

julia&gt; enddate(t)
1981-03-29T10:39:16.65</code></pre><p>See also: <a href="#Seis.startdate"><code>startdate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.endtime" href="#Seis.endtime"><code>Seis.endtime</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">endtime(t) -&gt; time</code></pre><p>Return the end <code>time</code> of trace <code>t</code> in seconds.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(5, 1, 3); # 3 samples at 1 Hz, starting at 5 s

julia&gt; endtime(t)
7.0</code></pre><p>See also: <a href="#Seis.starttime"><code>starttime</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.frequencies" href="#Seis.frequencies"><code>Seis.frequencies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frequencies(f)</code></pre><p>Return the frequency in Hz of each data point in the frequency domain trace <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; f = fft(sample_data());

julia&gt; frequencies(f)
0.0f0:0.1f0:50.0f0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.is_east" href="#Seis.is_east"><code>Seis.is_east</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_east(s::Station; tol) -&gt; ::Bool
is_east(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> or station <code>s</code> is horizontal and points to the east.</p><p>The azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p>See also: <a href="#Seis.is_north"><code>is_north</code></a>, <a href="#Seis.is_vertical"><code>is_vertical</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.is_north" href="#Seis.is_north"><code>Seis.is_north</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_north(s::Station{T}; tol) where T -&gt; ::Bool
is_north(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is horizontal and points to the north.</p><p>The azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p>See also: <a href="#Seis.is_east"><code>is_east</code></a>, <a href="#Seis.is_vertical"><code>is_vertical</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.is_horizontal" href="#Seis.is_horizontal"><code>Seis.is_horizontal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_horizontal(s::Station; tol)
is_horizontal(t::AbstractTrace; tol) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is horizontal (i.e., its inclination is 90° from the vertical), and <code>false</code> otherwise.</p><p>The inclination of the trace is compared to the horizontal within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; s = Station(azi=0, inc=90);

julia&gt; is_horizontal(s)
true

julia&gt; t = sample_data();

julia&gt; is_horizontal(t)
false

julia&gt; t.sta.inc
0.0f0</code></pre><p>See also: <a href="#Seis.is_vertical"><code>is_vertical</code></a>, <a href="#Seis.is_east"><code>is_east</code></a>, <a href="#Seis.is_north"><code>is_north</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.is_vertical" href="#Seis.is_vertical"><code>Seis.is_vertical</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_vertical(s::Station{T}; tol=eps(T)) where T
is_vertical(t::AbstractTrace; tol=eps(eltype(trace(t)))) -&gt; ::Bool</code></pre><p>Return <code>true</code> if the trace <code>t</code> is vertical (i.e., its inclination is 0°), and <code>false</code> otherwise.</p><p>The inclination of the trace is compared to the vertical within a tolerance of <code>tol</code>°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to <code>tol</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; s = Station(azi=0, inc=90);

julia&gt; is_vertical(s)
false

julia&gt; t = sample_data();

julia&gt; is_vertical(t)
true</code></pre><p>See also: <a href="#Seis.is_horizontal"><code>is_horizontal</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.nearest_sample" href="#Seis.nearest_sample"><code>Seis.nearest_sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearest_sample(t::AbstractTrace, time; inside=true) -&gt; i</code></pre><p>Return the index <code>i</code> of the nearest sample of the trace <code>t</code> to <code>time</code> seconds.</p><p>If <code>inside</code> is <code>true</code> (the default), return <code>nothing</code> when <code>time</code> lies outside the trace.  Set <code>inside</code> to <code>false</code> to instead return the first or last index when <code>time</code> is outside the trace.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, rand(5)); # Trace starting at 0 s, 1 Hz sampling

julia&gt; nearest_sample(t, 2)
3

julia&gt; nearest_sample(t, -1)

julia&gt; nearest_sample(t, -1, inside=false)
1</code></pre></div></section><section><div><pre><code class="language-julia hljs">nearest_sample(t::AbstractTrace, datetime::DateTime; inside=true)</code></pre><p>Form of <code>nearest_sample</code> where <code>datetime</code> is given as absolute time.</p><p>An error is thrown if no origin time is specified for <code>t.evt.time</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using Dates: DateTime, Second

julia&gt; t = sample_data();

julia&gt; nearest_sample(t, DateTime(1981, 03, 29, 10, 39, 7))
35

julia&gt; nearest_sample(t, startdate(t) - Second(10)) # 10 s before the first sample

julia&gt; nearest_sample(t, startdate(t) -  Second(10), inside=false)
1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.nfrequencies" href="#Seis.nfrequencies"><code>Seis.nfrequencies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nfrequencies(f)</code></pre><p>Return the number of frequency points in the frequency domain trace <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; f = fft(sample_data());

julia&gt; nfrequencies(f)
501</code></pre><p>See also: <a href="#Seis.nsamples"><code>nsamples</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.nsamples" href="#Seis.nsamples"><code>Seis.nsamples</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nsamples(f::AbstraceFourierTrace[; even::Bool])</code></pre><p>For a <code>FourierTrace</code> <code>f</code>, return the number of samples in the equivalent time domain trace.</p><p>The Fourier trace <code>f</code> records the number of points in the original trace used to create it with a call to <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a>, however if the length of the trace has been changed, the number of samples of the time-domain equivalent of <code>f</code> may be odd or even.  In this case, pass either <code>even=true</code> to return the even number of sample, or <code>even=false</code> for the odd.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data(); nsamples(t)
1000

julia&gt; f = fft(t);

julia&gt; nsamples(f)
1000</code></pre><p>See also: <a href="#Seis.nfrequencies"><code>nfrequencies</code></a></p></div></section><section><div><pre><code class="language-julia hljs">nsamples(t) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; data = rand(4);

julia&gt; t = Trace(0, 1, data);

julia&gt; nsamples(t)
4</code></pre></div></section><section><div><pre><code class="language-julia hljs">nsamples(t, b, e) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code> between times <code>b</code> and <code>e</code> seconds.</p><p>This function only counts samples that are strictly on or later than the <code>b</code> time, and before or on the <code>e</code> time.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, 25); # 25 samples from 0s to 24 s

julia&gt; nsamples(t, 3, 4.1)
2</code></pre><p>See also: <a href="#Seis.nearest_sample"><code>nearest_sample</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">nsamples(t, start::DateTime, stop::DateTime) -&gt; n</code></pre><p>Return the number of samples <code>n</code> in a trace <code>t</code> between dates <code>start</code> and <code>stop</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using Dates

julia&gt; t = Trace(10, 1, 20); # 20 samples from 10 to 30 s

julia&gt; t.evt.time = DateTime(3000)
3000-01-01T00:00:00

julia&gt; nsamples(t, DateTime(3000), DateTime(3000) + Second(9))
0

julia&gt; nsamples(t, DateTime(3000) + Second(20), DateTime(3000) + Second(22))
3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.origin_time" href="#Seis.origin_time"><code>Seis.origin_time</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">origin_time(t, time::DateTime; picks=true) -&gt; t′</code></pre><p>Return a copy to <code>t</code> where the event origin time is shifted to <code>time</code>.</p><p>See the in-place version <a href="#Seis.origin_time!"><code>origin_time!</code></a> for more details.</p></div></section><section><div><pre><code class="language-julia hljs">origin_time(t) -&gt; ::Dates.DateTime</code></pre><p>Return the origin time of the trace <code>t</code>, which is the point in time to which samples are referenced.  In this single-argument method, the trace <code>t</code> is unchanged.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; origin_time(t)
1981-03-29T10:38:14</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.picks" href="#Seis.picks"><code>Seis.picks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">picks(t; sort=:time) -&gt; p::Vector{Tuple{&lt;:AbstractString,&lt;:AbstractFloat}}</code></pre><p>Return a vector <code>p</code> of <code>Seis.Pick</code>s, which contain pairs of pick times and names associated with the <code>Trace</code> <code>t</code>.</p><p><code>sort</code> can be one of:</p><ul><li><code>:time</code> (the default): Picks are returned in order of increasing time</li><li><code>:name</code>: Picks are sorted alphanumerically by name, with unnamed picks first</li></ul><p>The returned vector can be iterated like:</p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, rand(10));

julia&gt; add_pick!.(t, (1,2), (&quot;P&quot;,&quot;S&quot;));

julia&gt; for (time, name) in picks(t) @show time, name end
(time, name) = (1.0, &quot;P&quot;)
(time, name) = (2.0, &quot;S&quot;)</code></pre></div></section><section><div><pre><code class="language-julia hljs">picks(t, name::AbstractString; sort=:time) -&gt; p
picks(t, pattern::Regex; sort=:time) -&gt; p</code></pre><p>Return a vector <code>p</code> of pairs of pick names and times associated with the <code>Trace</code> <code>t</code> which either are exactly <code>name</code> or match the regular expression <code>pattern</code>.</p><p>By default, picks are returned in order of increasing time.  Use <code>sort=:name</code> to sort alphanumerically by name (where unnamed picks appear first).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, 2); t.picks.P = (1, &quot;Pn&quot;); t.picks.S = (1.8, &quot;S&quot;);

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:
  :P =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;Pn&quot;)
  :S =&gt; Seis.Pick{Float64}(time=1.8, name=&quot;S&quot;)

julia&gt; picks(t, &quot;S&quot;)
1-element Array{Seis.Pick{Float64},1}:
 Seis.Pick{Float64}(time=1.8, name=&quot;S&quot;)

julia&gt; picks(t, r&quot;^P&quot;)
1-element Array{Seis.Pick{Float64},1}:
 Seis.Pick{Float64}(time=1.0, name=&quot;Pn&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.startdate" href="#Seis.startdate"><code>Seis.startdate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">startdate(t) -&gt; date</code></pre><p>Return the <code>date</code> of the first sample of the trace <code>t</code>.</p><p>N.B.  This function assumes that the sampling interval <code>t.delta</code> is representable as an integer number of milliseconds, and rounds it accordingly.  <code>Dates.DateTime</code>s have precision of 1 ms.  An error is thrown if <code>t.delta &lt; 1e-3</code> s.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data(); t.evt.time
1981-03-29T10:38:14

julia&gt; startdate(t)
1981-03-29T10:39:06.66</code></pre><p>See also: <a href="#Seis.enddate"><code>enddate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.starttime" href="#Seis.starttime"><code>Seis.starttime</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">starttime(f::FourierTrace)</code></pre><p>Return the time of the first sample of the equivalent time-domain recording which would be obtained by <a href="#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>ifft</code></a></p></div></section><section><div><pre><code class="language-julia hljs">starttime(t) -&gt; time</code></pre><p>Return the start <code>time</code> of trace <code>t</code> in seconds.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(-3, 0.01, rand(20)) # Set start time to -3;

julia&gt; starttime(t)
-3.0</code></pre><p>See also: <a href="#Seis.endtime"><code>endtime</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.times" href="#Seis.times"><code>Seis.times</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">times(t) -&gt; range</code></pre><p>Return the set of times <code>range</code> at which each sample of the trace <code>t</code> is defined.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; times(t)
52.66f0:0.01f0:62.65f0</code></pre><p>See also: <a href="#Seis.dates"><code>dates</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.trace" href="#Seis.trace"><code>Seis.trace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(f::FourierTrace)</code></pre><p>Return the data for a <a href="#Seis.FourierTrace"><code>FourierTrace</code></a> object.</p></div></section><section><div><pre><code class="language-julia hljs">trace(t) -&gt; data</code></pre><p>Return an array <code>data</code> containing the values of the <code>Trace</code> <code>t</code> at each sampling point.  <code>data</code> is now a variable bound to <code>t</code>s values, and changing <code>data</code> will change <code>t</code>.  <code>trace(t)</code> may itself also be modified and the trace will be updated.</p><div class="admonition is-info" id="Note-4fac840d446a7c6c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4fac840d446a7c6c" title="Permalink"></a></header><div class="admonition-body"><p>The value returned by <code>trace</code> is a variable bound to an internal field of the trace.  Therefore, assigning another value to <code>trace(t)</code> or <code>data</code> will <strong>not</strong> update the values in <code>t</code>.  Instead, update the values in-place using the <code>.</code> operator (like <code>data .= 1</code>).  See examples below.</p></div></div><div class="admonition is-info" id="Note-83034dff17466c53"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-83034dff17466c53" title="Permalink"></a></header><div class="admonition-body"><p>The underlying data array holding the trace can be rebound by assigning to the trace&#39;s field <code>t</code>, but this is unsupported and may break in future.</p></div></div><p><strong>Examples</strong></p><p>Retrieving the data values for a trace, and modifying the first value.</p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; data = trace(t)
1000-element Array{Float32,1}:
 -0.09728001
 -0.09728001
  ⋮
 -0.0768
 -0.0768

julia&gt; data[1] = 0;

julia&gt; trace(t)
1000-element Array{Float32,1}:
  0.0
 -0.09728001
  ⋮
 -0.0768
 -0.0768</code></pre><p>Setting the data values for a new synthetic trace.</p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.01, 1000); # 1000-point, 100 Hz trace with random data

julia&gt; trace(t) .= sin.(π.*times(t));

julia&gt; trace(t)
1000-element Array{Float64,1}:
  0.0
  0.03141075907812829
  ⋮
 -0.06279051952931425
 -0.031410759078131116</code></pre></div></section></article><h2 id="Setter-functions"><a class="docs-heading-anchor" href="#Setter-functions">Setter functions</a><a id="Setter-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Setter-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.add_pick!" href="#Seis.add_pick!"><code>Seis.add_pick!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_pick!(t, time [, name=missing]) -&gt; ::Seis.Pick</code></pre><p>Add an arrival time pick to the Trace <code>t</code>, ensuring existing picks are not overwritten, and return the <code>Seis.Pick</code> object added to the trace</p><p>If <code>name</code> is not <code>missing</code>, then the key of this pick will be <code>Symbol(name)</code>, unless another pick with the same key already exists.  In that case, the name will be appended with a number which increases until an available key is found.</p><p>If <code>name</code> is missing, then the pick is added to a numbered set of picks.</p><p>(Direct manipulation of picks is easy: just do <code>t.picks.PKP = (1001, &quot;PKP&quot;)</code> to set a picks with name &quot;PKP&quot;, time 1001 s and key <code>:PKP</code>.)</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, 2);

julia&gt; add_pick!.(t, [1, 2], [&quot;A&quot;, missing]);

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:
  :A =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)
  1  =&gt; Seis.Pick{Float64}(time=2.0, name=missing)

julia&gt; add_pick!(t, 4)
Seis.Pick{Float64}(time=4.0, name=missing)

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 3 entries:
  :A =&gt; Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)
  2  =&gt; Seis.Pick{Float64}(time=4.0, name=missing)
  1  =&gt; Seis.Pick{Float64}(time=2.0, name=missing)

julia&gt; t.picks.A
Seis.Pick{Float64}(time=1.0, name=&quot;A&quot;)

julia&gt; t.picks[1]
Seis.Pick{Float64}(time=2.0, name=missing)</code></pre><p>See also: <a href="../internal-index/#Seis.Pick"><code>Seis.Pick</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">add_pick!(t, date::Dates.AbstractDateTime[, name=missing]) -&gt; ::Seis.Pick</code></pre><p>Add a time pick based on absolute time, given as a <code>DateTime</code> or another <code>AbstractDateTime</code>.</p><div class="admonition is-info" id="Note-84a6c6efe587aefb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-84a6c6efe587aefb" title="Permalink"></a></header><div class="admonition-body"><p>The pick is converted to relative time, so does not remain independent of any changes to <code>t.b</code> or <code>t.evt.time</code> if you update the trace manually. Use <a href="#Seis.origin_time!"><code>origin_time!</code></a> to change the origin time whilst preserving the absolute time of picks.</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; using Dates

julia&gt; add_pick!(t, DateTime(&quot;1981-03-29T10:39:10&quot;), &quot;Coffee time&quot;)
Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)

julia&gt; picks(t)
3-element Vector{Seis.Pick{Float32}}:
 Seis.Pick{Float32}(time=53.670002, name=missing)
 Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)
 Seis.Pick{Float32}(time=60.980003, name=missing)</code></pre></div></section><section><div><pre><code class="language-julia hljs">add_pick!(t, p::Pick, name=p.name) -&gt; p</code></pre><p>Add a travel time pick to the <code>Trace</code> <code>t</code> from a <code>Seis.Pick</code>.  By default, the pick name is used.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t1 = Trace(0, 1, 20); t2 = sample_data();

julia&gt; add_pick!(t1, t2.picks.A, &quot;A&quot;)
Seis.Pick{Float64}(time=53.67000198364258, name=&quot;A&quot;)

julia&gt; t1.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 1 entry:
  :A =&gt; Seis.Pick{Float64}(time=53.67000198364258, name=&quot;A&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.add_picks!" href="#Seis.add_picks!"><code>Seis.add_picks!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_picks!</code></pre><p>Add picks to traces based on seismic phases&#39; predicted arrival time.</p><p>Seis does not itself implement seismic phase travel time computation. See <a href="https://github.com/anowacki/SeisTau.jl">SeisTau</a> for one implementation which adds methods to <code>add_pick!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.clear_picks!" href="#Seis.clear_picks!"><code>Seis.clear_picks!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear_picks!(t)</code></pre><p>Remove all picks associated with the <code>Trace</code> <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; picks(t)
2-element Array{Seis.Pick{Float32},1}:
 Seis.Pick{Float32}(time=53.670002, name=missing)
 Seis.Pick{Float32}(time=60.980003, name=missing)

julia&gt; clear_picks!(t);

julia&gt; picks(t)
0-element Array{Seis.Pick{Float32},1}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.origin_time!" href="#Seis.origin_time!"><code>Seis.origin_time!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">origin_time!(t, time::DateTime; picks=true) -&gt; t</code></pre><p>Set the origin time of the trace <code>t</code> and shift the start time of the trace (stored in its <code>.b</code> field) so that the absolute time of all samples remains the same.</p><p><code>origin_time!</code> will also shift all pick times so that they remain at the same absolute time.  Set <code>picks=false</code> to leave picks at the same time relative to the trace start time.</p><p>If <code>t.evt.time</code> is <code>missing</code> (i.e., unset), then it is simply set to <code>time</code> and no times are shifted.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using Dates

julia&gt; t = sample_data(); t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:
  :F =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)

julia&gt; t.evt.time
1981-03-29T10:38:14

julia&gt; origin_time!(t, t.evt.time + Second(1)); t.evt.time
1981-03-29T10:38:15

julia&gt; t.picks
Seis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:
  :F =&gt; Seis.Pick{Float32}(time=59.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=52.670002, name=missing)</code></pre></div></section></article><h2 id="Geometry-functions"><a class="docs-heading-anchor" href="#Geometry-functions">Geometry functions</a><a id="Geometry-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.azimuth" href="#Seis.azimuth"><code>Seis.azimuth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">azimuth(trace; sphere=false, flattening=Geodesics.F_WGS84) -&gt; az
azimuth(event, station; sphere=false, flattening=Geodesics.F_WGS84) -&gt; az</code></pre><p>Return the azimuth <code>az</code> from the event to the station (a seismic station) in degrees east from local north at the event for a <code>trace</code>.  Alternatively specify the <code>event</code> and <code>station</code> individually.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.backazimuth" href="#Seis.backazimuth"><code>Seis.backazimuth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">backazimuth(trace; flattening=0.0033528106718309896) -&gt; baz
backazimuth(station, event; flattening=0.0033528106718309896) -&gt; baz</code></pre><p>Return the backazimuth <code>baz</code> from the station (a seismic station) to an event in degrees east from local north at the station for a <code>trace</code>.  Alternatively specify the <code>station</code> and <code>event</code> individually.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.distance_deg" href="#Seis.distance_deg"><code>Seis.distance_deg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_deg(trace; sphere=false, flattening=0.0033528106718309896) -&gt; Δ
distance_deg(station, event; sphere=false, flattening=0.0033528106718309896) -&gt; Δ
distance_deg(event, station; sphere=false, flattening=0.0033528106718309896) -&gt; Δ</code></pre><p>For a <code>trace</code> or an <code>event</code>-<code>station</code> pair, return the epicentral angular distance <code>Δ</code> in degrees.</p><p>Optionally specify the <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.distance_direct" href="#Seis.distance_direct"><code>Seis.distance_direct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_direct(trace)
distance_direct(event, station)
distance_direct(station, event)</code></pre><p>For a cartesian <code>trace</code> or <code>event</code>-<code>station</code> pair, return the straight-line distance between them in <strong><code>m</code></strong>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.distance_km" href="#Seis.distance_km"><code>Seis.distance_km</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_km(event, station; sphere=false, a=6378.137, flattening=0.0033528106718309896) -&gt; d</code></pre><p>For a geographic <code>trace</code> or <code>event</code>–<code>station</code> pair, return the epicentral surface distance <code>d</code> in km between them.</p><p>Optionally specify the semimajor radius <code>a</code> in km and <code>flattening</code> of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.    If <code>sphere</code> is <code>true</code>, then <code>flattening</code> is set to zero and the calculation is performed on a sphere.</p></div></section><section><div><pre><code class="language-julia hljs">distance_km(event, station) -&gt; d</code></pre><p>For a cartesian <code>trace</code> or <code>event</code>-<code>station</code> pair, return the epicentral distance in km between them.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.incidence" href="#Seis.incidence"><code>Seis.incidence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">incidence(event, station) -&gt; i
incidence(trace) -&gt; i</code></pre><p>Return the angle of incidence <code>i</code>° between a cartesian <code>event</code> and <code>station</code>, or a cartesian <code>trace</code>.  The angle of incidence is defined downwards from the positive z (upward) direction.</p></div></section></article><h2 id="Trace-operations"><a class="docs-heading-anchor" href="#Trace-operations">Trace operations</a><a id="Trace-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.cut!" href="#Seis.cut!"><code>Seis.cut!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cut!(t, start, end; allowempty=false, warn=true) -&gt; t</code></pre><p>Cut a <code>Trace</code> <code>t</code> in place between <code>start</code> and <code>end</code>.  An error is thrown if either <code>start</code> or <code>end</code> are <code>missing</code>.</p><p>An error is thrown if the trace would be empty because either the end cut time is before the start of the trace, or the start cut is after the end, unless <code>allowempty</code> is <code>true</code>.</p><p>By default, a warning is shown if cut times lie outside the trace; set <code>warn</code> to <code>false</code> to turn this off.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, 2, 3, 4, 5]);

julia&gt; trace(cut!(t, 2, 4))
3-element Array{Float64,1}:
 2.0
 3.0
 4.0</code></pre><hr/><pre><code class="nohighlight hljs">cut!(t, start_date, end_date; kwargs...) -&gt; t</code></pre><p>Cut a <code>Trace</code> <code>t</code> in place between dates <code>start_date</code> and <code>end_date</code>.</p><p><strong>Example</strong></p><p>Create a trace starting at midnight on 1 January 3000, and cut to between 10 s and 1 minute after midnight:</p><pre><code class="nohighlight hljs">julia&gt; using Dates: DateTime

julia&gt; t = Trace(0, 1, 100); # 1 Hz sampling for 100 s;

julia&gt; t.evt.time = DateTime(3000, 1, 1); # The year 3000;

julia&gt; cut!(t, DateTime(3000, 1, 1, 0, 0, 10), DateTime(3000, 1, 1, 0, 1, 0))
Seis.Trace{Float64,Vector{Float64},Seis.Geographic{Float64}}:
            b: 10.0
        delta: 1.0
 GeogStation{Float64}:
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float64}:
     evt.time: 3000-01-01T00:00:00
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 0
         meta: 

julia&gt; startdate(t), enddate(t)
(DateTime(&quot;3000-01-01T00:00:10&quot;), DateTime(&quot;3000-01-01T00:01:00&quot;))</code></pre></div></section><section><div><pre><code class="language-julia hljs">cut!(t, pick1, offset1, pick2, offset; kwargs...) -&gt; t
cut!(t, pick, offset1, offset2; kwargs...) -&gt;</code></pre><p>Cut a trace <code>t</code> in place between <code>offset1</code> s after the first pick <code>pick1</code> and <code>offset2</code> s after <code>pick2</code>.</p><p>In the second form, both offsets are relative to <code>pick</code>.</p><p>The values of <code>pick1</code>, <code>pick2</code> and <code>pick</code> are passed to <a href="#Seis.picks"><code>picks</code></a> and so may be a <code>Symbol</code> (giving the key of the pick), a <code>String</code> (giving the pick name) or a <code>Regex</code> (which matches the pick name).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; starttime(t), endtime(t)
(52.66f0, 62.65f0)

julia&gt; cut!(t, :A, 0, :F, 1);

julia&gt; starttime(t), endtime(t)
(53.67f0, 61.979996f0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.cut" href="#Seis.cut"><code>Seis.cut</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cut(t, start, end; kwargs...) -&gt; t′
cut(t, start_date, end_date; kwargs...) -&gt; t′
cut(t, pick1, offset1, pick2, offset2; kwargs...) -&gt; t′
cut(t, pick, offset1, offset2; kwargs...) -&gt; t′</code></pre><p>Return a copy of the trace <code>t</code> cut between <code>start</code> and <code>end</code> s relative to the event origin.  You may also specify a <code>start_date</code> and <code>end_date</code>, or choose times <code>offset1</code> and <code>offset2</code> s relative to <code>pick1</code> and <code>pick2</code> respectively.  Both offset times may also be specified relative to one <code>pick</code>.</p><p>See also: <a href="#Seis.cut!"><code>cut!</code></a>, <a href="#Seis.picks"><code>picks</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.decimate!" href="#Seis.decimate!"><code>Seis.decimate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decimate!(t, n; antialias=true) -&gt; t
decimate(t, n; antialias=true) -&gt; t′</code></pre><p>Decimate the trace <code>t</code> by removing all except every <code>n</code> points.  The sampling interval is increased <code>n</code> times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>By default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.</p><p>If <code>antialias</code> is <code>false</code>, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.decimate" href="#Seis.decimate"><code>Seis.decimate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decimate!(t, n; antialias=true) -&gt; t
decimate(t, n; antialias=true) -&gt; t′</code></pre><p>Decimate the trace <code>t</code> by removing all except every <code>n</code> points.  The sampling interval is increased <code>n</code> times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>By default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.</p><p>If <code>antialias</code> is <code>false</code>, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.differentiate!" href="#Seis.differentiate!"><code>Seis.differentiate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate!(t::Trace; points=2) -&gt; t
differentiate(t::Trace; points=2) -&gt; t′</code></pre><p>Differentiate the trace <code>t</code> by performing <code>points</code>-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Available algorithms</strong></p><ul><li><code>points == 2</code>: Two-point.  <code>dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta</code>. Non-central difference, so <code>t.b</code> is increased by half <code>t.delta</code>. The trace length is reduced by 1 samples.</li><li><code>points == 3</code>: Three-point. <code>dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta)</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; the trace length is reduced by 2 samples.</li><li><code>points == 5</code>: Five-point. <code>dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta</code>, except for the first and last points, which use a three-point central difference meaning only two points fewer are retained as for <code>points == 3</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; <code>npts</code> reduced by 2.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, -1, 0]);

julia&gt; d = differentiate(t); trace(d)
3-element Array{Float64,1}:
  1.0
 -2.0
  1.0

julia&gt; starttime(d)
0.5</code></pre></div></section><section><div><pre><code class="language-julia hljs">differentiate!(t::AbstractFourierTrace) -&gt; t</code></pre><p>Differentiate the frequency-domain trace <code>t</code> in the Fourier domain by multiplying the cofficients <span>$Y_k$</span> by <span>$2\pi f_k i k$</span>, where <span>$k &lt;= N/2$</span> and <span>$N$</span> is the number of samples in the time-domain trace <code>ifft(t)</code> and <span>$f_k$</span> is the frequency corresponding to that coefficient. The operation is performed in-place.</p><p>To return an updated copy, use the out-of-place form <a href="#Seis.differentiate"><code>differentiate(::AbstractFourierTrace)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.differentiate" href="#Seis.differentiate"><code>Seis.differentiate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate!(t::Trace; points=2) -&gt; t
differentiate(t::Trace; points=2) -&gt; t′</code></pre><p>Differentiate the trace <code>t</code> by performing <code>points</code>-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Available algorithms</strong></p><ul><li><code>points == 2</code>: Two-point.  <code>dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta</code>. Non-central difference, so <code>t.b</code> is increased by half <code>t.delta</code>. The trace length is reduced by 1 samples.</li><li><code>points == 3</code>: Three-point. <code>dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta)</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; the trace length is reduced by 2 samples.</li><li><code>points == 5</code>: Five-point. <code>dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta</code>, except for the first and last points, which use a three-point central difference meaning only two points fewer are retained as for <code>points == 3</code>. Central difference.  <code>t.b</code> is increased by <code>t.delta</code>; <code>npts</code> reduced by 2.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, -1, 0]);

julia&gt; d = differentiate(t); trace(d)
3-element Array{Float64,1}:
  1.0
 -2.0
  1.0

julia&gt; starttime(d)
0.5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.envelope!" href="#Seis.envelope!"><code>Seis.envelope!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">envelope!(t::Trace) -&gt; t
envelope(t::Trace) -&gt; t′</code></pre><p>Replace the trace <code>t</code> with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);

julia&gt; trace(envelope(t))
8-element Array{Float64,1}:
 0.10355339059327379
 0.10355339059327379
 0.6035533905932737
 1.1680225577002512
 1.1680225577002512
 0.6035533905932737
 0.10355339059327373
 0.10355339059327379</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.envelope" href="#Seis.envelope"><code>Seis.envelope</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">envelope!(t::Trace) -&gt; t
envelope(t::Trace) -&gt; t′</code></pre><p>Replace the trace <code>t</code> with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);

julia&gt; trace(envelope(t))
8-element Array{Float64,1}:
 0.10355339059327379
 0.10355339059327379
 0.6035533905932737
 1.1680225577002512
 1.1680225577002512
 0.6035533905932737
 0.10355339059327373
 0.10355339059327379</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.fft-Tuple{Trace}" href="#AbstractFFTs.fft-Tuple{Trace}"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fft(t::Trace) -&gt; f::FourierTrace</code></pre><p>Convert the trace <code>t</code> into its equivalent frequency domain trace <code>f</code> by performing a Fourier transform.  The object returned is a <a href="#Seis.FourierTrace"><code>FourierTrace</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.01, 1000); trace(t) .= sin.(2π.*times(t)); # Sine wave of frequency 1 Hz

julia&gt; f = fft(t);

julia&gt; indmax = argmax(abs.(trace(f))); # Get index of maximum power

julia&gt; frequencies(f)[indmax] # Maximum frequency in Hz is 1 as expected
1.0</code></pre><p>See also: <a href="#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>ifft</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.flip!" href="#Seis.flip!"><code>Seis.flip!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip!(t) -&gt; t
flip(t) -&gt; t′</code></pre><p>Reverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.</p><p>The <code>t.sta</code> must contain both azimuth and inclination information.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s

julia&gt; t.sta.azi, t.sta.inc = 0, 90 # North horizontal component
(0, 90)

julia&gt; flip!(t)
Seis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 1.0
 Station{Float64,Seis.Geographic{Float64}}:
      sta.cha: 180.0
      sta.azi: 180.0
      sta.inc: 90.0
     sta.meta: Seis.SeisDict{Symbol,Any}()
 Event{Float64,Seis.Geographic{Float64}}:
     evt.meta: Seis.SeisDict{Symbol,Any}()
 Trace:
        picks: 0
         meta: 

julia&gt; trace(t)
3-element Array{Float64,1}:
 -0.0
 -1.0
 -0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.flip" href="#Seis.flip"><code>Seis.flip</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip!(t) -&gt; t
flip(t) -&gt; t′</code></pre><p>Reverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.</p><p>The <code>t.sta</code> must contain both azimuth and inclination information.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s

julia&gt; t.sta.azi, t.sta.inc = 0, 90 # North horizontal component
(0, 90)

julia&gt; flip!(t)
Seis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 1.0
 Station{Float64,Seis.Geographic{Float64}}:
      sta.cha: 180.0
      sta.azi: 180.0
      sta.inc: 90.0
     sta.meta: Seis.SeisDict{Symbol,Any}()
 Event{Float64,Seis.Geographic{Float64}}:
     evt.meta: Seis.SeisDict{Symbol,Any}()
 Trace:
        picks: 0
         meta: 

julia&gt; trace(t)
3-element Array{Float64,1}:
 -0.0
 -1.0
 -0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.ifft-Tuple{FourierTrace}" href="#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>AbstractFFTs.ifft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ifft(t::FourierTrace[, d=2*nfrequencies(f) - 2]) -&gt; t::Trace</code></pre><p>Convert the frequency domain <a href="#Seis.FourierTrace"><code>FourierTrace</code></a> <code>f</code> back into its equivalent time domain <a href="#Seis.Trace"><code>Trace</code></a> <code>t</code>.</p><p>Because <code>FourierTrace</code>s are usually constructed by calling <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a> on a <code>Trace</code>, the original number of time samples is kept in <code>f</code> and <code>t</code> therefore contains the same number of samples as before so long as the raw data in <code>f</code> has not been shortened or lengthened.  If it has, then it is assumed that <code>t</code> should have an even number of points.  If instead <code>t</code> should have an odd number of point, pass <code>d=npts</code>, where <code>npts</code> is the number of points needed.  <code>d</code> must be either one or two less than double the number of frequency points in <code>t</code>.</p><p><strong>Example</strong></p><p>Showing that taking the inverse Fourier transform of the Fourier domain trace <code>f</code> gets us back to <code>t</code>:</p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; f = fft(t);

julia&gt; t′ = ifft(f);

julia&gt; isapprox(trace(t), trace(t′))
true</code></pre><p>A crude method to upsample a trace:</p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [0, 1, 0, -1, 0]);

julia&gt; f = fft(t);

julia&gt; append!(trace(f), zeros(nfrequencies(f)));

julia&gt; trace(ifft(f))
10-element Vector{Float64}:
  0.0
  0.447213595499958
  1.0
  0.894427190999916
 -1.7763568394002506e-16
 -0.894427190999916
 -1.0
 -0.44721359549995787
  1.7763568394002506e-16
  0.0</code></pre><p>See also: <a href="#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.integrate!" href="#Seis.integrate!"><code>Seis.integrate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate!(t::Trace, method=:trapezium) -&gt; t
integrate(t::Trace, method=:trapezium) -&gt; t′</code></pre><p>Replace <code>t</code> with its time-integral.  This is done by default using the trapezium rule. Use <code>method=:rectangle</code> to use the rectangle rule.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>If <code>method==:trapezium</code> (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, 1, 1, 0]);

julia&gt; trace(integrate(t))
3-element Array{Float64,1}:
 0.05
 0.15000000000000002
 0.2

julia&gt; trace(integrate(t, :rectangle))
4-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.2</code></pre></div></section><section><div><pre><code class="language-julia hljs">integrate!(t::AbstractFourierTrace) -&gt; t</code></pre><p>Integrate the frequency-domain trace <code>t</code> in the Fourier domain by dividing the cofficients <span>$Y_k$</span> by <span>$2\pi f_k i k$</span>, where <span>$k &lt;= N/2$</span> and <span>$N$</span> is the number of samples in the time-domain trace <code>ifft(t)</code> and <span>$f_k$</span> is the frequency corresponding to that coefficient. The operation is performed in-place.</p><p>Note that in this implementation, the zero-frequency (DC) term is set to zero, such that differentiating the result of this function may produce a different trace to that which was originally integrated.</p><p>To return an updated copy, use the out-of-place form <a href="#Seis.integrate"><code>integrate(::AbstractFourierTrace)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.integrate" href="#Seis.integrate"><code>Seis.integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate!(t::Trace, method=:trapezium) -&gt; t
integrate(t::Trace, method=:trapezium) -&gt; t′</code></pre><p>Replace <code>t</code> with its time-integral.  This is done by default using the trapezium rule. Use <code>method=:rectangle</code> to use the rectangle rule.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>If <code>method==:trapezium</code> (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, 1, 1, 0]);

julia&gt; trace(integrate(t))
3-element Array{Float64,1}:
 0.05
 0.15000000000000002
 0.2

julia&gt; trace(integrate(t, :rectangle))
4-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge!-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}" href="#Base.merge!-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge!(t1::AbstractTrace, ts::AbstractArray{&lt;:AbstractTrace}; gaps=:zero, overlaps=:mean, sample_tol=0.1, check=true) -&gt; t1
merge!(t1, ts...; kwargs...) -&gt; t1
merge!([t1, ts...]; kwargs...) -&gt; t1

merge(t1::AbstractTrace, ts::AbstractArray{&lt;:AbstractTrace}; gaps=:zero, overlaps=:mean, sample_tol=0.1, check=true) -&gt; t1
merge(t1, ts...; kwargs...) -&gt; t1
merge([t1, ts...]; kwargs...) -&gt; t1</code></pre><p>Merge two or more traces together into the first trace, retaining only station and event information from the first trace.</p><p>In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>All traces must have the same sampling interval.  They must also have the same channel code (see <a href="#Seis.channel_code"><code>channel_code</code></a>), unless <code>check</code> is <code>false</code>. The traces do not need to have the same element type or geometry.</p><p>Where gaps between traces occur, these may be filled in a number of different ways, or an error may be thrown.  Tapering may be applied to the data either side of gaps.  See &#39;Keyword arguments&#39; below for details.</p><p>Likewise, where overlaps occur, either data from the first or last trace in each overlap may be used, or the mean of the traces used.  Other options are also possible.</p><p>If the start times of traces (and hence each sample itself) are not quantised in time in the same way, then an error is thrown, unless the difference in quantisation is less than a fraction of <code>sample_tol</code> of the sampling interval.  Hence <code>sample_tol</code> should be between 0 and 0.5.</p><p>If all traces have an event time set, then merging is done in absolute time.  If not all have an event time set, then all times are assumed to be relative to the same origin and only the traces&#39; <code>b</code> fields are used.  To perform merging in relative time regardless of whether the origin time is set, pass <code>relative = true</code>.</p><p>Empty traces are checked for matching channel codes, but are not otherwise merged into the final trace.  If all traces are empty, the first is returned unaltered.</p><p><strong>Keyword arguments</strong></p><p><strong><code>gaps</code></strong></p><p><code>gaps</code> controls how gaps between continuous segments of data are treated, and may take one of the following values:</p><ul><li><code>:zero</code> (default): Fill any gaps with zero</li><li><code>:error</code>: Throw an error if any gaps are present</li><li><code>:linear</code>: Linearly interpolate between the last sample before the gap and the first sample after the gap.  Cannot be used with tapering.</li><li><code>value</code>: Fill with <code>value</code>, which must be convertable to the element type of <code>t1</code>.</li></ul><p><strong><code>overlaps</code></strong></p><p><code>overlaps</code> controls how the new merged trace uses traces which overlap in time, and may take one of the following values:</p><ul><li><code>:mean</code> (default): Take the mean of the values at each overlapping sample</li><li><code>:first</code>: Use the data from the first (in time) trace in the overlap</li><li><code>:last</code>: Use the data from the last (in time) trace</li><li><code>:zero</code>: Zero out any overlapping periods</li><li><code>:error</code>: Throw an error if any overlaps are present and the data are not identical.  (Note that the error type is not at present defined but may be in a future version.)</li><li><code>value</code>: Fill with <code>value</code>, which must be convertable to the element type of <code>t1</code>.</li></ul><p><strong><code>sample_tol</code></strong></p><p>Any trace which does not have its samples quantised to the same as <code>t1</code> to within a fraction of a sampling interval <code>sample_tol</code> will cause an error to be thrown.  Set this to a value between 0 and 0.5 to control this.  A value of 0.5 will mean any quantisation differences are ignored.</p><p><strong><code>taper</code></strong></p><p>If <code>taper</code> is set to a fractional width, a taper is performed on the ends of traces adjoining gaps, with <code>taper</code> defining the proportional length of the taper relative to the gap length.  Values are tapered to 0.</p><p>Note that if <code>taper</code> is used with a number for <code>gaps</code>, then sharp jumps will occur at the first and last sample of each gap to whatever <code>value</code> is supplied to the <code>gaps</code> argument</p><p><strong><code>taper_form</code></strong></p><p>Determines the type of taper applied around gaps if <code>taper</code> is set. This can be one of <code>:hanning</code> (the default), <code>:hamming</code> or <code>:cosine</code>. See <a href="#Seis.taper!"><code>taper!</code></a> for details.</p><p><strong><code>relative</code></strong></p><p>If <code>relative</code> is <code>true</code>, then ignore any origin times in traces and merge them all only with regard to their <a href="#Seis.starttime"><code>starttime</code></a>. By default merging is done in absolute time if all traces have <code>.evt.time</code> set.</p><p><strong><code>metadata</code></strong></p><p>If <code>true</code> (the default), then entries in the <code>.meta</code> field of each trace are merged into the <code>.meta</code> field of the first trace.  Entries of the first trace are preserved, while entries not in the first trace are added in turn from the last trace to the first.  This means duplicate entries are not overwritten in the first trace, and entries present in more than one of the other traces are taken from the second, third, etc., trace in preference to any later traces.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}" href="#Base.merge-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge(t1::AbstractTrace, t2::AbstractTrace...) -&gt; t_merged
merge(t1::AbstractTrace, ::Vararg{AbstractTrace}) -&gt; t_merged
merge(ts::AbstractArray{&lt;:AbstractTrace}) -&gt; t_merged</code></pre><p>For details of out-of-place trace merging, see <a href="#Base.merge!-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}"><code>merge!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.normalise!" href="#Seis.normalise!"><code>Seis.normalise!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.normalise" href="#Seis.normalise"><code>Seis.normalise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise!(t::Trace, val=1) -&gt; t
normalise(t::Trace, val=1) -&gt; t′</code></pre><p>Normalise the trace <code>t</code> so that its maximum absolute amplitude is <code>val</code>. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.</p><p>This function can also be spelled <code>normalize[!]</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.1, [0, -1, 2]);

julia&gt; trace(normalise(t))
3-element Array{Float64,1}:
  0.0
 -0.5
  1.0

julia&gt; trace(normalise(t, 2))
3-element Array{Float64,1}:
  0.0
 -1.0
  2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.remove_mean!" href="#Seis.remove_mean!"><code>Seis.remove_mean!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_mean!(t::Trace) -&gt; t
remove_mean(t::Trace) -&gt; t′</code></pre><p>Remove the mean of trace <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.01, [1, 1, 3, -1]);

julia&gt; trace(remove_mean(t))
4-element Array{Float64,1}:
  0.0
  0.0
  2.0
 -2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.remove_mean" href="#Seis.remove_mean"><code>Seis.remove_mean</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_mean!(t::Trace) -&gt; t
remove_mean(t::Trace) -&gt; t′</code></pre><p>Remove the mean of trace <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.01, [1, 1, 3, -1]);

julia&gt; trace(remove_mean(t))
4-element Array{Float64,1}:
  0.0
  0.0
  2.0
 -2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.remove_trend!" href="#Seis.remove_trend!"><code>Seis.remove_trend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_trend!(t::Trace) -&gt; t
remove_trend(t::Trace) -&gt; t′</code></pre><p>Remove the trend from <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.2, [1, 2, 3, 4]);

julia&gt; trace(remove_trend(t))
4-element Array{Float64,1}:
 -2.220446049250313e-16
  0.0
  0.0
  4.440892098500626e-16</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.remove_trend" href="#Seis.remove_trend"><code>Seis.remove_trend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_trend!(t::Trace) -&gt; t
remove_trend(t::Trace) -&gt; t′</code></pre><p>Remove the trend from <code>t</code>.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.2, [1, 2, 3, 4]);

julia&gt; trace(remove_trend(t))
4-element Array{Float64,1}:
 -2.220446049250313e-16
  0.0
  0.0
  4.440892098500626e-16</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.resample!" href="#Seis.resample!"><code>Seis.resample!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample!(t::AbstractTrace; delta, n) -&gt; t
resample(t::AbstractTrace; delta, n) -&gt; t′</code></pre><p>Resample the trace <code>t</code> so that either the sampling interval becomes <code>delta</code> s, or its sampling rate is increased <code>n</code> times.  One of <code>delta</code> or <code>n</code> must be given.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy (<code>t′</code>).</p><p>The functions uses <a href="#DSP.Filters.resample"><code>DSP.resample</code></a> to perform the operation, which applies an antialias filter and &#39;additional operations&#39; to prevent aliasing and minimise other artifacts.</p><p>To perform decimation without antialiasing, use <a href="#Seis.decimate"><code>decimate</code></a> or <a href="#Seis.decimate!"><code>decimate!</code></a> with <code>antialias=false</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.5, 1:4);

julia&gt; trace(resample(t, 3))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.resample" href="#DSP.Filters.resample"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample!(t::AbstractTrace; delta, n) -&gt; t
resample(t::AbstractTrace; delta, n) -&gt; t′</code></pre><p>Resample the trace <code>t</code> so that either the sampling interval becomes <code>delta</code> s, or its sampling rate is increased <code>n</code> times.  One of <code>delta</code> or <code>n</code> must be given.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy (<code>t′</code>).</p><p>The functions uses <a href="#DSP.Filters.resample"><code>DSP.resample</code></a> to perform the operation, which applies an antialias filter and &#39;additional operations&#39; to prevent aliasing and minimise other artifacts.</p><p>To perform decimation without antialiasing, use <a href="#Seis.decimate"><code>decimate</code></a> or <a href="#Seis.decimate!"><code>decimate!</code></a> with <code>antialias=false</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 0.5, 1:4);

julia&gt; trace(resample(t, 3))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Periodograms.spectrogram-Tuple{AbstractTrace}" href="#DSP.Periodograms.spectrogram-Tuple{AbstractTrace}"><code>DSP.Periodograms.spectrogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectrogram(trace::AbstractTrace; length=(endtime(t) - starttime(t))/20, overlap=0.5, window=nothing, pad=nothing) -&gt; spec</code></pre><p>Calculate the spectrogram for the data in <code>trace</code>.  Each segment is <code>length</code> s long, and overlaps with the next by a fraction of <code>overlap</code> (i.e., <code>overlap</code> must be 0 s or greater, and less than 1).  Note that these values are rounded to an integer number of samples in both cases.</p><p>Windows are by default padded to the next length which allows for fast FFT computation.  Setting <code>pad</code> to a number larger than 1 pads the trace with zeroes to the nearest integer length which is <code>pad</code> times the trace length. This allows for finer sampling in frequency space.</p><p>By default, no windowing of each segment (of <code>length</code> s) is performed; pass a windowing function or vector of amplitudes to <code>window</code> to window each segment before the periodogram is computed.  See <code>DSP.periodogram</code> for more details of the kind of windowing which is possible.  (The spectrogram calculation is performed by <code>DSP.spectrogram</code> and returns a <code>DSP.Periodograms.Spectrogram</code> object.)</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; t = sample_data();

julia&gt; spec = spectrogram(t);

julia&gt; spec.time
52.90999984741211:0.25:62.40999984741211</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.taper!" href="#Seis.taper!"><code>Seis.taper!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">taper!(t::AbstractTrace, width=0.05; left=true, right=true, form=:hanning, time=nothing) -&gt; t
taper(t::AbstractTrace, width=0.05; left=true, right=true, form=:hamming, time=nothing) -&gt; t′</code></pre><p>Apply a taper to the ends of the data in trace <code>t</code>. <code>form</code> may be one of <code>:hanning</code>, <code>:hamming</code> or <code>:cosine</code>. <code>width</code> represents the fraction (at both ends) of the trace tapered, up to 0.5.</p><p>Optionally, specify <code>time</code> as an absolute length in time for the tapering period (at both ends), in which case <code>width</code> is ignored.</p><p>By default, tapering is applied to both ends.  If <code>left</code> is <code>false</code>, then only the &#39;right&#39; end (later in time part) of the trace is tapered; and vice versa.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);

julia&gt; trace(taper(t))
6-element Array{Float64,1}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0

julia&gt; trace(taper(t; time=0.25))
6-element Vector{Float64}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0

julia&gt; trace(taper(t; right=false))
6-element Vector{Float64}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -1.0
  1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.taper" href="#Seis.taper"><code>Seis.taper</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">taper!(t::AbstractTrace, width=0.05; left=true, right=true, form=:hanning, time=nothing) -&gt; t
taper(t::AbstractTrace, width=0.05; left=true, right=true, form=:hamming, time=nothing) -&gt; t′</code></pre><p>Apply a taper to the ends of the data in trace <code>t</code>. <code>form</code> may be one of <code>:hanning</code>, <code>:hamming</code> or <code>:cosine</code>. <code>width</code> represents the fraction (at both ends) of the trace tapered, up to 0.5.</p><p>Optionally, specify <code>time</code> as an absolute length in time for the tapering period (at both ends), in which case <code>width</code> is ignored.</p><p>By default, tapering is applied to both ends.  If <code>left</code> is <code>false</code>, then only the &#39;right&#39; end (later in time part) of the trace is tapered; and vice versa.</p><p>In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);

julia&gt; trace(taper(t))
6-element Array{Float64,1}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0

julia&gt; trace(taper(t; time=0.25))
6-element Vector{Float64}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -0.49999999999999994
  0.0

julia&gt; trace(taper(t; right=false))
6-element Vector{Float64}:
 -0.0
  0.49999999999999994
 -1.0
  1.0
 -1.0
  1.0</code></pre></div></section></article><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.bandstop!" href="#Seis.bandstop!"><code>Seis.bandstop!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
bandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a bandreject filter to the trace <code>t</code> with stop band between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.bandstop" href="#Seis.bandstop"><code>Seis.bandstop</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
bandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a bandreject filter to the trace <code>t</code> with stop band between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.bandpass!" href="#Seis.bandpass!"><code>Seis.bandpass!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t
bandpass(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t′</code></pre><p>Apply a bandpass filter to the trace <code>t</code> between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.bandpass" href="#Seis.bandpass"><code>Seis.bandpass</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t
bandpass(t::Trace, f1, f2; poles=2, twopass=false) -&gt; t′</code></pre><p>Apply a bandpass filter to the trace <code>t</code> between frequencies <code>f1</code> and <code>f2</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.highpass!" href="#Seis.highpass!"><code>Seis.highpass!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
highpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a highpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.highpass" href="#Seis.highpass"><code>Seis.highpass</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
highpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a highpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.lowpass!" href="#Seis.lowpass!"><code>Seis.lowpass!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
lowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a lowpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.lowpass" href="#Seis.lowpass"><code>Seis.lowpass</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t
lowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -&gt; t′</code></pre><p>Apply a lowpass filter to the trace <code>t</code> with corner frequency <code>f</code> in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.</p><p>Optionally specify the number of <code>poles</code> of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.</p><p>Specify the <code>kind</code> of filter by providing a kind from the <code>DSP.Filters</code> module. If doing so, the <code>poles</code> keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.</p></div></section></article><h2 id="Trace-rotation"><a class="docs-heading-anchor" href="#Trace-rotation">Trace rotation</a><a id="Trace-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-rotation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_through!" href="#Seis.rotate_through!"><code>Seis.rotate_through!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_through!(t1::Trace, t2::Trace, phi[; tol]) -&gt; t1, t2</code></pre><p>For two traces <code>t1</code> an <code>t2</code> which are orthgonal, rotate them by <code>phi</code>° from <code>t1</code> towards <code>t2</code>.  Note therefore that the <strong>order of the arguments matters</strong> and opposite rotations can be achieved by swapping <code>t1</code> and <code>t2</code>.  Neither of the traces need to be horizontal.</p><p>This is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate from <code>t2</code> to <code>t1</code>.</p><p>Trace channel names are updated to contain the azimuth if both channels are horizontals.</p><p>The optional keyword argument <code>tol</code> specifies the angle in ° by which the traces must be orthogonal; see <a href="#Seis.are_orthogonal"><code>are_orthogonal</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; e, n = sample_data(:local)[1:2];

julia&gt; rotate_through!(n, e, 20); # Rotate 20° clockwise looking down

julia&gt; n.sta.azi, e.sta.azi
(20.0f0, 110.0f0)

julia&gt; rotate_through!(e, n, 20); # Rotate in opposite direction

julia&gt; n.sta.azi, e.sta.azi
(6.5939315f-7, 90.0f0)</code></pre><p>See also: <a href="#Seis.rotate_through"><code>rotate_through</code></a>, <a href="#Seis.rotate_to_gcp!"><code>rotate_to_gcp!</code></a>, <a href="#Seis.rotate_to_azimuth_incidence!"><code>rotate_to_azimuth_incidence!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_through" href="#Seis.rotate_through"><code>Seis.rotate_through</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_through!(t1::Trace, t2::Trace, phi[; tol]) -&gt; t1, t2</code></pre><p>For two traces <code>t1</code> an <code>t2</code> which are orthgonal, rotate them by <code>phi</code>° from <code>t1</code> towards <code>t2</code>.  Note therefore that the <strong>order of the arguments matters</strong> and opposite rotations can be achieved by swapping <code>t1</code> and <code>t2</code>.  Neither of the traces need to be horizontal.</p><p>This is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate from <code>t2</code> to <code>t1</code>.</p><p>Trace channel names are updated to contain the azimuth if both channels are horizontals.</p><p>The optional keyword argument <code>tol</code> specifies the angle in ° by which the traces must be orthogonal; see <a href="#Seis.are_orthogonal"><code>are_orthogonal</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; e, n = sample_data(:local)[1:2];

julia&gt; rotate_through!(n, e, 20); # Rotate 20° clockwise looking down

julia&gt; n.sta.azi, e.sta.azi
(20.0f0, 110.0f0)

julia&gt; rotate_through!(e, n, 20); # Rotate in opposite direction

julia&gt; n.sta.azi, e.sta.azi
(6.5939315f-7, 90.0f0)</code></pre><p>See also: <a href="#Seis.rotate_through"><code>rotate_through</code></a>, <a href="#Seis.rotate_to_gcp!"><code>rotate_to_gcp!</code></a>, <a href="#Seis.rotate_to_azimuth_incidence!"><code>rotate_to_azimuth_incidence!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_enz!" href="#Seis.rotate_to_enz!"><code>Seis.rotate_to_enz!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_enz!(t1, t2, t3[; tol]) -&gt; e, n, z</code></pre><p>Rotate three orthogonal traces <code>t1</code>, <code>t2</code> and <code>t3</code> in place so that they point east (<code>e</code>), north (<code>n</code>) and vertically (<code>z</code>).</p><p><code>e</code>, <code>n</code> and <code>z</code> are bindings to the same data as <code>t1</code>, <code>t2</code> and <code>t3</code>, but they may not be returned in the same order as passed in if the original set of traces are not given as a right-handed set.</p><p>See also: <a href="#Seis.rotate_through!"><code>rotate_through!</code></a>, <a href="#Seis.rotate_to_gcp!"><code>rotate_to_gcp!</code></a>, <a href="#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_enz" href="#Seis.rotate_to_enz"><code>Seis.rotate_to_enz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_enz(t1, t2, t3[; tol]) -&gt; e, n, z</code></pre><p>Copying version of <a href="#Seis.rotate_to_enz!"><code>rotate_to_enz!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_gcp!" href="#Seis.rotate_to_gcp!"><code>Seis.rotate_to_gcp!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_gcp!(t1, t2; reverse=false, tol) -&gt; t1, t2</code></pre><p>Rotate the pair of traces <code>t1</code> and <code>t2</code> in place so that <code>t1</code> points along the radial direction (the backazimuth plus 180°), and <code>t2</code> is 90° clockwise from that.</p><p>If <code>reverse</code> is <code>true</code>, then <code>t2</code> is rotated to be 90° anticlockwise from <code>t1</code>, so that the polarity is reversed.</p><p>The component names of the radial and transverse traces are updated to be &#39;R&#39;, and either &#39;T&#39; or &#39;-T&#39; respectively for normal and reverse polarity, unless the component code is a valid SEED identifier which seems rotatable and matches for the traces; then the correct component name is used. (E.g., <code>&quot;BHE&quot;</code> and <code>&quot;BHN&quot;</code> become <code>&quot;BHR&quot;</code> and <code>&quot;BHT&quot;</code>.)</p><p>Traces must be orthogonal and horizontal.  The optional keyword argument <code>tol</code> specifies the angle in ° by which the traces must be orthogonal; see <a href="#Seis.are_orthogonal"><code>are_orthogonal</code></a>.</p><p>See also: <a href="#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a>, <a href="#Seis.rotate_to_azimuth_incidence!"><code>rotate_to_azimuth_incidence!</code></a>, <a href="#Seis.rotate_to_enz!"><code>rotate_to_enz!</code></a></p></div></section><section><div><pre><code class="language-julia hljs">rotate_to_gcp!(t::AbstractArray{T}; kwargs...) -&gt; t</code></pre><p>Rotate pairs of traces in the array <code>t</code> so they are in the order <code>[R1, T1, R2, T2, ...]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_gcp" href="#Seis.rotate_to_gcp"><code>Seis.rotate_to_gcp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_gcp(t1, t2; reverse=false[, tol]) -&gt; R, T
rotate_to_gcp(t::AbstractArray{&lt;:AbstractTrace}; reverse=false[, tol]) -&gt; t′</code></pre><p>Copying version of <code>rotate_to_gcp!</code> which returns the radial <code>R</code> and transverse <code>T</code> traces in the first form, or pairs of radial and transverse traces in the modified array <code>t′</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_lqt!" href="#Seis.rotate_to_lqt!"><code>Seis.rotate_to_lqt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_lqt!(t1, t2, t3; [tol]) -&gt; L, Q, T
rotate_to_lqt!(t1, t2, t3, incidence; [tol]) -&gt; L, Q, T
rotate_to_lqt!(t1, t2, t3, azimuth, incidence; [tol]) -&gt; L, Q, T</code></pre><p>Rotate the three traces <code>t1</code>, <code>t2</code> and <code>t3</code> in place, and return them in the order <code>L</code>, <code>Q</code> and <code>T</code>, forming a right-handed set.</p><p>The <code>L</code> trace records positive motion along the event-receiver direction, defined by the local <code>azimuth</code> at the receiver (i.e., backazimuth + 180°) and <code>incidence</code> angle (measured downwards away from the positive upwards direction).</p><p>The <code>T</code> direction is transverse to <code>L</code>, such that when looking along the direction towards the station, <code>T</code> is on the right and lies in the horizontal plane.</p><p>The <code>Q</code> direction is perpendicular to both, lying in the saggital plane, with some component in the vertical direction.</p><p>If <code>azimuth</code> and <code>inclination</code> are not passed in explicitly, then they are determined using the event-station geometry.  This is only possible for both for <code>Trace</code>s in Cartesian geometry, since <code>inclination</code> is not well-determined in a geographic system.  Geographic-system traces (the default) must pass at least the <code>inclination</code>.  For the Cartesian case, we assume straight-line paths between event and receiver.</p><p><code>tol</code> specifies the angle in ° by which the traces must be orthogonal; see <a href="#Seis.are_orthogonal"><code>are_orthogonal</code></a></p><div class="admonition is-info" id="Note-ed63fa89053fcd3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ed63fa89053fcd3" title="Permalink"></a></header><div class="admonition-body"><p>If <code>incidence</code> is 0° or 90° (the direction is vertical), then the choice of <code>Q</code> and <code>T</code> is arbitrary and simply chosen such that <code>Q</code> points along the local <code>azimuth</code>.</p></div></div><p><strong>Diagram</strong></p><p><strong>Plan view</strong></p><pre><code class="nohighlight hljs"> ⋆ (event)       North
  `                ↑
    `              |
      `            |
        `
          ∇ (station)
         ⊙ `
      -  Q   `
    ↙          ↘
   T            L</code></pre><p><strong>Side view</strong></p><pre><code class="nohighlight hljs">                 Q
                 ↑
 Up               |
 ↑                 |
 |                  |      __ → L
 |      (station)  ∇ ⊙__---
             .__--   T
        .__--
    __--
  ⋆ (event)</code></pre><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; e, n, z = sample_data(:regional)[1:3];

julia&gt; azi = azimuth(e) + 180
216.85858118935954

julia&gt; inc = 30; # Determined from other calculation

julia&gt; l, q, t = rotate_to_lqt!(e, n, z, azi, inc)
(Seis.Trace(.ELK..1: delta=0.025, b=-5.000015, nsamples=12000), Seis.Trace(.ELK..2: delta=0.025, b=-5.000015, nsamples=12000), Seis.Trace(.ELK..T: delta=0.025, b=-5.000015, nsamples=12000))

julia&gt; l.sta.azi, l.sta.inc, l.sta.cha
(216.85858f0, 30.0f0, &quot;1&quot;)

julia&gt; t.sta.cha
&quot;T&quot;

julia&gt; l == e, q == n, t == z # Original traces are modified and returned in a possibly different order
(true, true, true)</code></pre><p>See also: <a href="#Seis.rotate_through!"><code>rotate_through!</code></a>, <a href="#Seis.rotate_to_azimuth_incidence!"><code>rotate_to_azimuth_incidence!</code></a>, <a href="#Seis.rotate_to_enz"><code>rotate_to_enz</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_lqt" href="#Seis.rotate_to_lqt"><code>Seis.rotate_to_lqt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_lqt(t1, t2, t3[, azimuth[, incidence]; tol) -&gt; l, q, t</code></pre><p>Copying version of <a href="#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_azimuth_incidence!" href="#Seis.rotate_to_azimuth_incidence!"><code>Seis.rotate_to_azimuth_incidence!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_azimuth_incidence!(t1, t2, t3, azimuth, incidence[; tol]) -&gt; x, y, z</code></pre><p>Rotate a mutually-orthogonal set of traces <code>t1</code>, <code>t2</code> and <code>t3</code> such that the trace <code>x</code> points along the direction defined by <code>azimuth</code>, <code>y</code> points perpendicular to <code>x</code> and has components only in the direction along <code>azimuth</code> and the vertical; <code>z</code> is perpendicular to both and lies in the horizontal plane. <code>x</code>, <code>y</code> and <code>z</code> form a right-handed set and are commonly known as L, Q and T respectively.  (See <a href="#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a>.)</p><p>Note that in this form, the underlying data and metadata in the input traces is altered, and the returned traces point to the same data as the input traces, but possibly in a different order.  Use <a href="#Seis.rotate_to_azimuth_incidence"><code>rotate_to_azimuth_incidence</code></a> to return copies of the traces and leave the original traces unmodified.</p><p>See also: <a href="#Seis.rotate_to_azimuth_incidence"><code>rotate_to_azimuth_incidence</code></a>, <a href="#Seis.rotate_to_gcp!"><code>rotate_to_gcp!</code></a>, <a href="#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a>, <a href="#Seis.rotate_through!"><code>rotate_through!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.rotate_to_azimuth_incidence" href="#Seis.rotate_to_azimuth_incidence"><code>Seis.rotate_to_azimuth_incidence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_to_azimuth_incidence(t1, t2, t3, azimuth, incidence[; tol]) -&gt; x, y, z</code></pre><p>Copying version of <a href="#Seis.rotate_to_azimuth_incidence"><code>rotate_to_azimuth_incidence</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.sort_traces_right_handed" href="#Seis.sort_traces_right_handed"><code>Seis.sort_traces_right_handed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_traces_right_handed(t1, t2, t3) -&gt; x, y, z, perm</code></pre><p>Sort the traces <code>t1</code>, <code>t2</code> and <code>t3</code> such that they form a right-handed set; requiring the traces to be mutually orthogonal.  The direction of <code>x</code>, <code>y</code> and <code>z</code> are arbitrary.  <code>perm</code> is a length-three tuple containing the indices (from 1 to 3) of the new order of traces, such that <code>x</code> is <code>(t1, t2, t3)[perm[1]]</code> and so on.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; e, n, z = sample_data(:regional)[1:3];

julia&gt; e.sta.cha, n.sta.cha, z.sta.cha # Confirm the order
(&quot;e&quot;, &quot;n&quot;, &quot;z&quot;)

julia&gt; u, v, w, perm = Seis.sort_traces_right_handed(n, e, z); # A left-handed arrangement

julia&gt; [u, v, w].sta.cha
3-element Vector{String}:
 &quot;n&quot;
 &quot;z&quot;
 &quot;e&quot;

julia&gt; [n, e, z][[perm...]] # Indexing by perm gives us the new order
3-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:
 Seis.Trace(.ELK..n: delta=0.025, b=-5.000015, nsamples=12000)
 Seis.Trace(.ELK..z: delta=0.025, b=-5.000015, nsamples=12000)
 Seis.Trace(.ELK..e: delta=0.025, b=-5.000015, nsamples=12000)</code></pre></div></section></article><h2 id="IO"><a class="docs-heading-anchor" href="#IO">IO</a><a id="IO-1"></a><a class="docs-heading-anchor-permalink" href="#IO" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.read_mseed" href="#Seis.read_mseed"><code>Seis.read_mseed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_mseed(file; kwargs...) -&gt; traces
read_mseed(file, T; kwargs...) -&gt; traces::Vector{T}</code></pre><p>Read a single miniseed file from disk and return a set of <code>Trace</code>s.</p><p>The <code>meta.mseed_file</code> field of each trace contains the file name. </p><p>Optionally specify the type of trace <code>T &lt;: AbstractTrace</code> to read.  By default, <code>T</code> is <code>Trace{Float64, Vector{Float32}, Seis.Geographic{Float64}}</code>, since almost all seismic data stored in Miniseed format is single-precision, and because the sampling rate is stored at a 64-bit float in miniSEED files.</p><p><strong>Example</strong></p><p>Read a single file:</p><pre><code class="nohighlight hljs">julia&gt; read_mseed(&quot;data.mseed&quot;)</code></pre><p>Read a single file assuming a Cartesian geometry:</p><pre><code class="nohighlight hljs">julia&gt; read_mseed(CartTrace{Float64, Vector{Float32}}, &quot;data.mseed&quot;)</code></pre><p><strong>Handling gapped/overlapped data</strong></p><p>When channels containing gaps or overlaps are encountered, they are split into multiple <code>Trace</code>s as each <code>Trace</code> must be continuous and evenly sampled.  However, data quite often contain single-sample offsets which are later corrected, and so these are ignored by default.</p><p>Use the keyword argument <code>maximum_gap</code> to control whether or not gaps cause new traces to be created.  See below for more details.</p><p><strong>Keyword arguments</strong></p><p>The following keyword arguments can be passed to <code>read_mseed</code>:</p><ul><li><p><code>headers_only = false</code>: If <code>true</code>, only read trace header information, leaving the returned traces empty.  In this case, the following additional fields in <code>.meta</code> are set:</p><ul><li><code>mseed_nsamples</code>: Number of samples in the trace</li><li><code>mseed_enddate</code>: <code>DateTime</code> of the final sample</li><li><code>mseed_endtime</code>: Time of the final sample</li></ul></li><li><p><code>maximum_gap</code>: The maximum absolute gap length in s beyond which gaps are no longer tolerated in a single trace.  By default this is the sampling interval of the trace being read.</p><div class="admonition is-info" id="Note-2914809e20159e52"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2914809e20159e52" title="Permalink"></a></header><div class="admonition-body"><p>Set <code>maximum_gap</code> to 0 to always split miniseed files into separate traces at all gaps.</p></div></div></li><li><p><code>verbose = 0</code>: An integer starting from 0 upwards indicating how much information about the reding process should be printed to the screen. The default (<code>0</code>) only produces output for errors and warnings.</p></li></ul><hr/><pre><code class="nohighlight hljs">read_mseed(data::Vector{UInt8}[, T]; kwargs...) -&gt; traces</code></pre><p>Read Miniseed <code>data</code> from memory, held as a set of bytes, optionally specifying the type <code>T</code> of traces to return.  Keyword arguments are the same as for reading from a file on disk.</p></div></section><section><div><pre><code class="language-julia hljs">read_mseed(pattern, dir) -&gt; ::Vector{&lt;:Trace}
read_mseed(pattern, dir, T) -&gt; Vector{T}</code></pre><p>Read all files matching <code>pattern</code> in directory <code>dir</code>.</p><p>See <code>Glob.glob</code> for details of pattern matching.</p><p>Optionally specify the type of trace <code>T &lt;: AbstractTrace</code> to read.</p><p><strong>Example</strong></p><p>Read all files matching <code>&quot;TA.*.BHZ.mseed&quot;</code> in all directories within <code>DATA</code> which themselves match <code>&quot;Event_??&quot;</code>:</p><pre><code class="nohighlight hljs">julia&gt; read_mseed(&quot;Event_??/TA.*.BHZ.mseed&quot;, &quot;DATA&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.read_sac" href="#Seis.read_sac"><code>Seis.read_sac</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_sac(file; terse=false, header_only=true) → ::Trace</code></pre><p>Read a single evenly-sampled SAC file and return a Trace.  If <code>terse</code> is <code>true</code>, then warn when auto-byteswapping files.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; file = joinpath(dirname(pathof(Seis)), &quot;..&quot;, &quot;data&quot;, &quot;seis.sac&quot;);

julia&gt; t = read_sac(file)
Seis.Trace{Float32,Vector{Float32},Seis.Geographic{Float32}}:
            b: 52.66
        delta: 0.01
 GeogStation{Float32}:
      sta.lon: -120.0
      sta.lat: 48.0
      sta.sta: CDV
      sta.azi: 0.0
      sta.inc: 0.0
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float32}:
      evt.lon: -125.0
      evt.lat: 48.0
      evt.dep: 0.0
     evt.time: 1981-03-29T10:38:14
       evt.id: K8108838
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 2
         meta: SAC_lpspol =&gt; true
               SAC_nevid =&gt; 0
               SAC_iftype =&gt; 1
               file =&gt; &quot;src/../data/seis.sac&quot;
               SAC_idep =&gt; 50
               SAC_iztype =&gt; 9
               SAC_lcalda =&gt; true
               SAC_unused18 =&gt; false
               SAC_lovrok =&gt; true
               SAC_norid =&gt; 0
               SAC_ievtyp =&gt; 42</code></pre><p><strong>Reading only headers</strong></p><p>To read only the headers from a SAC file, returning an empty trace, set <code>header_only</code> to <code>true</code>.  In this case, the trace&#39;s <code>meta</code> dictionary contains a pair <code>:SAC_npts =&gt; npts</code>, where <code>npts</code> is the number of data points as held in the SAC file&#39;s header.  Traces read from SAC files with <code>header_only</code> can used to overwrite the headers of files on disk, so long as <code>npts</code> is consistent.</p><hr/><pre><code class="nohighlight hljs">read_sac(glob, dir; echo=false, header_only=false) → ::Vector{Trace}</code></pre><p>Read SAC files which match the patern <code>glob</code> in directory <code>dir</code> and return a set of <code>Traces</code>.  Add the file names to <code>t.meta.file</code>.  These are relative paths.</p><p>File names matching the pattern are shown if <code>echo</code> is <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; dir = joinpath(dirname(pathof(Seis)), &quot;..&quot;, &quot;data&quot;, &quot;local&quot;);

julia&gt; t = read_sac(&quot;*.z&quot;, dir)
9-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:
 Seis.Trace(.CALZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CAOZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDAZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDVZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CMNZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CPSZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVAZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVLZ..: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVYZ..: delta=0.01017683, b=-7.690632, nsamples=3933)</code></pre><hr/><p><strong>SAC header conventions</strong></p><p>When reading SAC files, the following conventions are observed:</p><ul><li>The event id is held in header <code>KEVNM</code></li><li>Channel ID is held in <code>KCMPNM</code></li><li>Location ID is held in <code>KHOLE</code></li><li>If <code>O</code> and the file origin time parameters are set, <code>O</code> is shifted to 0 time, and all time picks are adjusted.  This is similar to using the commands <code>ch o gmt [date]; ch allt (0 - &amp;1,o&amp;)</code> to set the origin in SAC.</li><li>Time picks are added to the <code>Trace</code> picks.</li></ul><p>SAC headers which don&#39;t directly translate to <code>Trace</code> attributes are placed in the <code>.meta</code> field and have names prefixed by <code>&quot;SAC_&quot;</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.write_mseed" href="#Seis.write_mseed"><code>Seis.write_mseed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_mseed(file, t; append=false, verbose=0, pubversion=1, record_length=nothing, version=2)</code></pre><p>Write the data contained in the trace(s) <code>t</code> to <code>file</code> on disk in miniSEED format.</p><p><code>t</code> may be either a single <code>AbstractTrace</code>, or an array of <code>AbstractTrace</code>s.</p><p>miniSEED files can contain data in (amongst others) in <code>Float32</code>, <code>Float64</code> and <code>Int32</code> format.  This function will use whatever precision or type the data in <code>t</code> have and attempt to write.  If for example you want to write a trace with a <code>Float64</code> element type to a miniSEED file with element type <code>Float32</code>, you should first convert the trace using <code>convert</code>. (Note that since Seis does not support integer-valued trace data, it will not write 32-bit integer miniSEED files.)</p><p>If the trace does not have an origin time set, an error is thrown.</p><p><strong>Keyword arguments</strong></p><ul><li><code>append::Bool</code>: If <code>true</code>, add the data in <code>t</code> to the end of any data already existing in <code>file</code>.  miniSEED files can contain multiples traces.</li><li><code>verbose::Integer</code>: Controls the verbosity of the miniSEED conversion and writing process.  Larger values of <code>verbose</code> cause more output to be produced.</li><li><code>pubversion::Integer</code>: The publication version of data describes whether a set of data has been updated since being initially published.  Higher numbers correspond to records which supercede lower versions, which start at 1 (the default).</li><li><code>record_length::Integer</code>: The number of bytes used to write each miniSEED record.</li><li><code>version</code>: The miniSEED file version to write.  Can be <code>2</code> (the default) or <code>3</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.write_sac" href="#Seis.write_sac"><code>Seis.write_sac</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_sac(t, file; littleendian=false)
write_sac(t, io::IO; littleendian=false)</code></pre><p>Write the <code>Trace</code> <code>t</code> to a <code>file</code> on disk or an <code>IO</code> object in SAC format.</p><p>Keys in the <code>t.meta</code> field which begin with <code>SAC_</code> have their values written to the corresponding SAC field (e.g., <code>t.meta.SAC_kuser0</code> is written to the <code>KUSER0</code> header).  The user is responsible for ensuring that the values corresponding to these keys can be converted to the correct header type.  Note also that <code>SAC_</code> <code>meta</code> fields override the equivalent <code>Trace</code> headers (e.g., <code>t.sta.sta</code> is equivalent to <code>SAC_kstnm</code>) and so one way to override the values in <code>Trace</code> headers is to set the <code>SAC_</code> fields. Note that the header is lowercase (i.e., <code>SAC_kstnm</code> not <code>SAC_KSTNM</code>).</p><p>Time picks with keys corresponding to SAC picks headers (<code>A</code>, <code>F</code>, and <code>T0</code> to <code>T9</code>) are transferred, but other picks are not.</p><p>If <code>t</code> is in a Cartesian reference frame (i.e., its positions are given by <code>CartEvent</code> and <code>CartStation</code>), then the Cartesian station coordinates <code>x</code>, <code>y</code> and <code>z</code> are saved respectively to headers <code>USER0</code>, <code>USER1</code> and <code>USER2</code>. Likewise, the event coordinates are saved respectively to <code>USER3</code>, <code>USER4</code> and <code>USER5</code>.  Any information in <code>meta</code> fields <code>SAC_user0</code> to <code>SAC_user5</code> will overwrite this data.</p><div class="admonition is-info" id="Note-5627375d3ba78d4a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5627375d3ba78d4a" title="Permalink"></a></header><div class="admonition-body"><p>The convention on how non-geographic coordinates are written in SAC headers is not part of the API and may change at any time.  Saving non-standard information in SAC headers should be done explicitly by the user if this information is important.</p></div></div><p>By default, files are written to disk in bigendian format (MacSAC or SAC/BRIS convention).  Use <code>littleendian=true</code> to write in littleendian byte order (SAC/IRIS or SAC2000 convention).</p><p>See also: <a href="#Seis.read_sac"><code>read_sac</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.write_sac_header" href="#Seis.write_sac_header"><code>Seis.write_sac_header</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_sac_header(t, file; check=true, littleendian=false)</code></pre><p>Overwrite the equivalent SAC headers in the <code>Trace</code> <code>t</code> to <code>file</code> on disk or an IO object in SAC format.  This is especially useful to update the headers of files which have been read with <code>read_sac(file; header_only=true)</code>; see <a href="#Seis.read_sac"><code>read_sac</code></a>.</p><p>When <code>check</code> is <code>true</code> (the default), <code>write_sac_header</code> checks that <code>file</code> is an existing SAC trace with the correct number of points in the data trace, and will determine the file endianness in order to write the headers correctly.  However, if <code>check</code> is <code>false</code>, then no checks are made.  In this case, the header will be written in bigendian endianness (MacSAC or SAC/BRIS format) unless <code>littleendian</code> is <code>true</code>.  <code>littleendian</code> has no effect if <code>check</code> is <code>true</code>.</p><p>This function is useful for updating headers for files on disk without having to read and write the entire trace from and to the disk.</p><div class="admonition is-warning" id="Warning-1e7c71bdb3f3c7de"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1e7c71bdb3f3c7de" title="Permalink"></a></header><div class="admonition-body"><p>With the option <code>check=false</code>, no check is made that the header written to disk matches the trace on disk in any way.  Take care in particular to write a value of NPTS to the header which matches the number of points in the pre-existing SAC file.</p><p><code>overwrite_header</code> will happily overwrite the first bytes of <strong>ANY</strong> file you point it at if <code>check</code> is <code>false</code>, making no check that <code>file</code> is actually a SAC file.</p></div></div><div class="admonition is-info" id="Note-4970b65412ec7633"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4970b65412ec7633" title="Permalink"></a></header><div class="admonition-body"><p>The number of points stated in the header is taken from <code>t.meta.SAC_npts</code> if it is set, in which case the length of the trace in memory is ignored. If <code>t.meta</code> does not contain a <code>.SAC_npts</code> entry, then the number of data points is used to fill the NPTS SAC header.</p></div></div><p>See <a href="#Seis.write_sac"><code>write_sac</code></a> for more information on how headers are transferred from <code>Trace</code>s to SAC headers.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = Trace(0, 1, [1, 2, 3]);

julia&gt; file, _ = mktemp();

julia&gt; write_sac(t, file);

julia&gt; t.sta.lon, t.sta.lat = 15, 20; # Update coordindates

julia&gt; trace(t2) .= 0; # Change data

julia&gt; write_sac_header(t, file);

julia&gt; t2 = read_sac(file);

julia&gt; t2.sta
Seis.Station{Float32,Seis.Geographic{Float32}}:
             lon: 15.0
             lat: 20.0
             dep: missing
             net: missing
             sta: missing
             loc: missing
             cha: missing
            elev: missing
             azi: missing
             inc: missing
            meta: 

julia&gt; trace(t2) # Data on disk are not touched
3-element Vector{Float32}:
 1.0
 2.0
 3.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.SAC.SACTrace" href="#Seis.SAC.SACTrace"><code>Seis.SAC.SACTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SACTrace(delta, npts, b=0.) -&gt; ::SACTrace</code></pre><p>Construct a composite type holding an evenly-spaced SAC time-series trace, where the trace is accessed through the field name <code>t</code>.  Supply the constant sampling interval <code>delta</code> in seconds, and the number of points in the trace <code>t</code>.  Optionally, specify the trace start time <code>b</code> in seconds.</p><pre><code class="nohighlight hljs">SACTrace(v::AbstractVector, delta, b=0.) -&gt; ::SACTrace</code></pre><p>Construct a <code>SACTrace</code> by supplying an array <code>v</code>, sampling interval <code>delta</code> and optionally the starting time.</p><pre><code class="nohighlight hljs">SACTrace(d::Vector{UInt8}, file=&quot;&quot;; swap=true, terse=false, check_npts=true) -&gt; ::SACTrace</code></pre><p>Construct a SACTrace from a raw array of bytes representing some data in SAC format. If <code>swap</code> is false, then non-native-endian files are not converted.  If <code>terse</code> is true, then warnings about swapping are not written.  If <code>check_npts</code> is false, then parts of files are read without error.</p></div></section></article><h2 id="Example-data-sets"><a class="docs-heading-anchor" href="#Example-data-sets">Example data sets</a><a id="Example-data-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Example-data-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Seis.sample_data" href="#Seis.sample_data"><code>Seis.sample_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_data() -&gt; ::Trace
sample_data(kind::Symbol) -&gt; ::Array{Trace}</code></pre><p>Return some sample data.</p><p>With no arguments, <code>sample</code> gives one trace from a local earthquake recorded in California.</p><p>In the second form, a set of traces is returned according to the table below:</p><table><tr><th style="text-align: left"><code>kind</code></th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>:local</code></td><td style="text-align: left">Livermore Valley, CA.  9 3-component stations</td></tr><tr><td style="text-align: left"><code>:regional</code></td><td style="text-align: left">Nevada.  4 3-component stations</td></tr><tr><td style="text-align: left"><code>:teleseism</code></td><td style="text-align: left"><strong>Mid-period</strong> recording of Eureka, CA event.  4 3-c stations</td></tr><tr><td style="text-align: left"><code>:teleseisl</code></td><td style="text-align: left"><strong>Long-period</strong> recording of Eureka, CA event.  4 3-c stations</td></tr><tr><td style="text-align: left"><code>:array</code></td><td style="text-align: left">Deep Fiji event.  60 vertical stations in the UK</td></tr></table></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting-makie/">« Plotting with Makie.jl</a><a class="docs-footer-nextpage" href="../internal-index/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 22 August 2025 11:51">Friday 22 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
