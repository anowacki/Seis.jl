var documenterSearchIndex = {"docs":
[{"location":"manual/#User-manual","page":"Manual","title":"User manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This section describes how to use Seis to perform various basic processing operations on seismic data.","category":"page"},{"location":"manual/#Preamble","page":"Manual","title":"Preamble","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The examples in this manual all assume that you have first used the module like so:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Seis","category":"page"},{"location":"manual/#Sample-data","page":"Manual","title":"Sample data","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Seis comes with a small selection of sample data which will be used for the examples in this manual.  See the help for sample_data for details.","category":"page"},{"location":"manual/#Types","page":"Manual","title":"Types","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Working with Seis requires understanding a little bit about the types it uses.  Fundamentally, there are three important types:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Traces, which contain\nStations and\nEvents.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Each of these types have fields which either must contain data, or allow data to be missing.","category":"page"},{"location":"manual/#Traces","page":"Manual","title":"Traces","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Trace holds a single continuous record of evenly-sampled data. As such, it cannot contain gaps or overlaps.  It may be referenced to an absolute start time, and by convention all times of day in Seis are UTC. Equally, however, a trace may have no absolute reference time.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Traces have a small number of fields which are directly accessible by users:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"delta is the samping interval (1 / sampling rate) in s;\nb is the start time of the trace, relative to any absolute time if any;\nsta is a Station holding information about the site where this recording was made;\nevt is an Event holding information about any event related to this recording, such as an earthquake;\npicks holds a set of times of importance such as arrival picks; and\nmeta holds any other information.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"None of these fields can be missing.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To access the data stored in a trace, use the trace function to return the underlying array.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The user-accessible fields can be retrieved or modified as usual for composite types:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"# A trace starting a 0 s with sampling interval 1 s made of 100 random samples\nt = Trace(0, 1, rand(100))\n# Update the sampling interval to 0.1 s\nt.delta = 0.1","category":"page"},{"location":"manual/#Mutability","page":"Manual","title":"Mutability","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Traces are mutable.  This means that the values they hold can be changed by the user at will.  It is often useful to copy a trace after you have performed an operation on it.  Thoughout Seis, as with Julia generally, functions which modify a Trace have an exclamation mark (!) at the end of their name.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nTraces are 'parameterised' on the type of floating point numbers they use, the type of data storage, and the geometry in which they are defined (i.e., either in geographic or Cartesian coordinates). A Trace is technically a Trace{T, V, P} where {T, V, P}, where T is the number type used, V is the type of vector holding the trace data, and P is the geometry type. This is why a trace has a scary-looking type like Trace{Float32, Array{Float32, 1}, Seis.Geographic{Float32}}. You only need to deal with these type parameters if you want to change these defaults.  See Geometry for more information.","category":"page"},{"location":"manual/#Collections-of-Traces","page":"Manual","title":"Collections of Traces","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In Seis, methods are usually written to accept Traces.  There is no special container for several traces; instead you can use Arrays of traces just as you would any other collection of types.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, to find the epicentral distance between the earthquake and a number of recordings of it at different stations, you could use Julia's broadcasting feature to call the distance_deg function on each Trace.  (Note that the sample_data function returns a simple Vector{Trace} of recordings.)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = sample_data(:array)\ntypeof(t)\neltype(t)\ndistance_deg.(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To find the nearest station, you could write the following:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t[argmin(distance_deg.(t))].sta","category":"page"},{"location":"manual/#Stations","page":"Manual","title":"Stations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Stations define a stationary point in space where a recording was made. They have the following fields which you can access and modify:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"net, sta, loc and cha are used respectively for the network, station, channel and location names of a single recording channel. They correspond to the SEED channel naming convention, but all can be missing.\nlon, lat and elev are the longitude and latitude (in °, positive eastwards and northwards) of the station, whilst elev is the elevation above sea level in m.\nazi and inc together define the orientation of the channel; that is, in which spatial direction positive values point.  azi is the local azimuth in ° measured clockwise from north, whilst inc is the local inclination in ° measured from the vertical downwards.  For seismic data, vertical channels will have inc == 0 and azi == 0, whilst horizontal channels will have inc == 90 and azi == 0 for north and azi == 90 for east.\nmeta holds all other information.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"See Geometry for more details on other coordinate systems in which objects can be placed in Seis.","category":"page"},{"location":"manual/#Events","page":"Manual","title":"Events","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"An Event marks the source of a Trace.  Typically, it represents the source of energy for a recording, or it may simply indicate the start time of a section of data with no energy source implied.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Events have the following accessible fields, all of which can be missing:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"time is a Dates.DateTime giving an absolute date and time in UTC against which a Trace's b field (beginning time) is relative. For an earthquake or other source of energy, it should be the origin time of that event.\nlon, lat and dep are the longitude and latitude (in °) and depth (in km) of any identified source for the data, such as an earthquake.\nid is a String giving some identifying information about an event, and could be a catalogue ID or otherwise.\nmeta holds all other information.  By convention, the following fields in meta might be used:\nmag holds an event magnitude;\nquakeml holds information about an event in QuakeML form, if any;\ncatalog gives the name of the catalogue for this event.","category":"page"},{"location":"manual/#Getting-data-in","page":"Manual","title":"Getting data in","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Data can be loaded into Julia via a number of means:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Reading data from disk in SAC or miniSEED format.\nFor this use either read_sac or read_mseed.\nTo read a single file, use the one-argument form:\njulia> t1 = read_sac(\"single_file.sac\")\nSeis.Trace{Float32,Array{Float32,1},Seis.Geographic{Float32}}:\n           b: 52.66\n       delta: 0.01\nStation{Float32,Seis.Geographic{Float32}}:\n     sta.lon: -120.0\n     sta.lat: 48.0\n     sta.sta: CDV\n     sta.azi: 0.0\n     sta.inc: 0.0\n    sta.meta: Seis.SeisDict{Symbol,Any}()\nEvent{Float32,Seis.Geographic{Float32}}:\n     evt.lon: -125.0\n     evt.lat: 48.0\n     evt.dep: 0.0\n    evt.time: 1981-03-29T10:38:14\n      evt.id: K8108838\n    evt.meta: Seis.SeisDict{Symbol,Any}()\nTrace:\n       picks: 2\n        meta: SAC_lpspol => true\n              SAC_nevid => 0\n              SAC_iftype => 1\n              file => \"../test/test_data/seis.sac\"\n              SAC_idep => 50\n              SAC_iztype => 9\n              SAC_lcalda => true\n              SAC_unused18 => false\n              SAC_lovrok => true\n              SAC_norid => 0\n              SAC_ievtyp => 42\n\njulia> t2 = read_mseed(\"file.mseed\")\n2-element Array{Trace{Float32,Array{Float32,1},Seis.Geographic{Float32}},1}:\n Seis.Trace(GB.CWF..BHZ: delta=0.02, b=0.0, nsamples=3000)\n Seis.Trace(GB.CWF..HHZ: delta=0.01, b=0.0, nsamples=6000)\nnote: Note\nSAC files can contain only one single continuous data channel, whilst miniSEED files can contain more than one, and so an array of Traces are returned.\nReading several files using a globbing pattern:\njulia> read_sac(\"Event_*/*Z.sac\", \"DATA\")\nDownloading data from a remote server.\nFor this, install and use SeisRequests.\njulia> using SeisRequests\n\njulia> t = get_data(code=\"IU.ANMO.00.BH?\", starttime=\"2018-02-02\", endtime=\"2018-02-02T01:00:00\") # an hour of data\n[ Info: Request status: Successful request, results follow\n3-element Array{Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}},1}:\n Seis.Trace(IU.ANMO.00.BH1: delta=0.05, b=0.0, nsamples=72000)\n Seis.Trace(IU.ANMO.00.BH2: delta=0.05, b=0.0, nsamples=72000)\n Seis.Trace(IU.ANMO.00.BHZ: delta=0.05, b=0.0, nsamples=72000)","category":"page"},{"location":"manual/#Creating-data-from-scratch","page":"Manual","title":"Creating data from scratch","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Traces can be constructed using the constructors.  For example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"b = 0\ndelta = 0.01\ndata = randn(1000)\nt = Trace(b, delta, data) # Fill trace with data already available","category":"page"},{"location":"manual/#Writing-data-out","page":"Manual","title":"Writing data out","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Seis currently supports writing in SAC and miniSEED format, using respectively the write_sac and write_mseed functions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = sample_data()\nwrite_sac(t, \"outfile.sac\")\nwrite_mseed(t, \"outfile.mseed\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that miniSEED files can contain several traces, and so you can also pass an array of traces to write_mseed:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = sample_data(:local)\nwrite_mseed(t, \"local_data.mseed\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nTraces written in miniSEED format must have their .evt.time field set, since this is required in the file format.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nminiSEED files do not contain any information about the station or event.  The only information saved is the station network, station, location and channel codes and the start date of the first sample.","category":"page"},{"location":"manual/#Basic-processing","page":"Manual","title":"Basic processing","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Once read in or obtained some other way, data can be processed in a number of ways.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that, as mentioned above (Mutability), traces can be modified in place, or copies taken when processing steps are applied.  Modifying in place is usually faster as it does not involve copying all the information, but it is often more convenient to copy traces as well.  For this reason, there is always a modifying version of a function (ending in !), and a copying version, without.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cut the data to a certain window, in either relative time, absolute time, or relative to a time pick, with cut or cut!.\nDecimate the data, with or without an antialiasing filter (decimate, decimate!).\nRemove the mean value of the trace with remove_mean or remove_mean!.\nRemove a linear trend in the data with remove_trend or remove_trend!.\nTaper the signal with taper or taper!.\nFilter the data, performing a low-pass (lowpass, lowpass!), high-pass (highpass, highpass!), band-pass (bandpass, bandpass!) or band-stop (bandstop, bandstop!) filter.  For each, an acausal version of the filter can be obtained by passing the twopass=true option.\nDifferentiate (differentiate, differentiate!) or integrate (integrate, integrate!) the trace.\nNormalise the data to a certain value with normalize or normalize! (or normalise for us Brits).\nTake the envelope of a trace with envelope or envelope!.\nChange the trace sampling interval with resample or resample!","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In addition, sets of traces can be rotated:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"rotate_through and rotate_through! rotate a pair of traces by a certain angle.\nrotate_to_gcp and rotate_to_gcp! rotate pairs to radial (pointing away from the source at the station) and transverse (90° clockwise from this) components.\nrotate_to_lqt and rotate_to_lqt! rotate triplets of orthogonal compontents to longitudinal (L), transverse (T) and Q (orthogonal to the others) orientations.\nrotate_to_azimuth_incidence and rotate_to_azimuth_incidence! rotate triplets of orthogonal traces to arbitrary orientations.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All of the above will use trace header information (coordinate of the event and station, and channel orientations) to automatically compute the directions if possible.","category":"page"},{"location":"manual/#Accessing-raw-trace-data","page":"Manual","title":"Accessing raw trace data","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Beyond these basic functions, Traces are designed to be used to build your own processing workflows on top.  For example, shear wave splitting analysis can be done with SeisSplit and array processing with Beamforming.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To access the raw trace, use the trace function, which returns the data:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = Trace(0, 0.1, [1, 2, 3, 4, 5])\ndata = trace(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As is usual with Julia, data is a variable bound to the same object as the underlying data of the trace t.  Modifying data will also modify the values in t:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"data[1] = 0 # Set the first point to be zero\ntrace(t) # Note the first point is now 0","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"data can be empty!d, or push!ed or append!ed to, and so on—it is simply a vector of data points.","category":"page"},{"location":"manual/#Accessing-other-properties","page":"Manual","title":"Accessing other properties","text":"","category":"section"},{"location":"manual/#Times","page":"Manual","title":"Times","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first sample of a trace t occurs at time t.b, and each sample is t.delta seconds after the previous one.  Therefore, each sample of the trace has a time, and this array (actually a subtype of AbstractRange) can be obtained with times:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"times(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For consistency, the start and end times of a trace are given by starttime and endtime:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"starttime(t), endtime(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All these times are relative to the event date if that is set.  If it is, then startdate and enddate give the start and end date of the trace in UTC:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Dates\nt.evt.time = DateTime(2013, 5, 24, 5, 44, 49, 880) # Set the origin time\nstartdate(t), enddate(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Like before, we can get a set of dates for every sample with dates:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dates(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There should be 5 values here, since we gave the trace a set of 5 data points. nsamples tells us this:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"nsamples(t)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The closest sample to a certain time or date can be found with nearest_sample:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"nearest_sample(t, 0.11)\nnearest_sample(t, DateTime(2013, 5, 24, 5, 44, 50))","category":"page"},{"location":"manual/#Picks","page":"Manual","title":"Picks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Seis allows you to assign arbitrary time picks to a Trace and use these in flexible ways.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Picks are simply markers which label a certain point in time with a label. They are useful for marking particular phase arrivals and for other purposes.  All picks in Seis are relative to the origin time for the trace if any.  So if a trace's starttime is 3 s and a pick is at 4 s, the pick points to a time 1 s after the trace starts.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Picks have two fields: time and name.  time is the time in seconds after zero time, which is the event time if set.  name may be a String such as \"PcP\", or missing if no name is needed for this pick.","category":"page"},{"location":"manual/#Getting-picks","page":"Manual","title":"Getting picks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Picks are accessible in the picks field of a trace:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = sample_data();\nt.picks","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can see that there are two picks defined: one at 53.67 s with key :A, and one at 60.98 s with key :F.  Each pick is associated with a key, which can be a Symbol, or an Int.  Picks with a Symbol key are named picks and can be accessed in two ways.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can access a named pick with dot notation if you know the literal key:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks.A","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can also use getindex or [] notation to access a named pick using a variable bound to a Symbol or a literal value:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks[:A]\npickkey = :A; t.picks[pickkey]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For any pick, access its time and name like so:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks.A.time, t.picks.A.name","category":"page"},{"location":"manual/#Setting-picks","page":"Manual","title":"Setting picks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Setting picks is done similarly.  To add a named pick with name :S, time 2 s and name \"Sg\", you can do","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks.S = 2, \"Sg\"\nt.picks","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Or, you can use setindex! ([]):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks[:S] = 2.5\nt.picks","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that the :S pick is overwritten.  Note also here that by not providing a name for the pick, its name defaults to missing.","category":"page"},{"location":"manual/#Removing-picks","page":"Manual","title":"Removing picks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Remove picks as usual for Dict-like collections of things, with delete!:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"delete!(t.picks, :S)\nt.picks","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can also use the special method for the picks field of setting a pick to missing:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t.picks.F = missing\nt.picks","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Remove all picks with the clear_picks! function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"clear_picks!(t)\nt.picks","category":"page"},{"location":"manual/#Arrays-of-picks","page":"Manual","title":"Arrays of picks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Because t.picks is a special type of Dict (a Seis.SeisDict), we can also access the time and name fields of sets of picks easily.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, if dealing with a set of stations where we have a pick for each, we can extract the vector of all pick times simply:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = sample_data(:array)\nt[1].picks # Picks of the first trace\nt.picks.A.time # Times of all A picks for all traces","category":"page"},{"location":"manual/#Geometry","page":"Manual","title":"Geometry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Seis allows you to have traces defined in any coordinate system you like. By default, it provides two main types:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Geographic, where coordinates are given as longitudes and latitudes in °, and depths in km below sea level, and\nCartesian, where coordinates are x, y and z in a right-handed system and each is given in m.  Conventionally in Seis, x is a local easting and y is a local northing, meaning z is the upwards direction and usually z is 0 at sea level or the local reference level.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"By default in Seis, all Events, Stations and Traces are geographic, and use the Geographic type.  Therefore you do not need to do anything special to work in geographic sense with longitudes, latitudes, and so on.","category":"page"},{"location":"manual/#Cartesian-geometry","page":"Manual","title":"Cartesian geometry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"However, if you are dealing with data where it makes more sense to consider positions in a Cartesian system, that is straightforward. Use the special constructors for Cartesian objects to create them:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CartTrace creates a new Trace in an x y z system.\nCartStation creates a Cartesian-referenced Station.\nCartEvent makes a Cartesian-referenced event.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Where it makes sense, certain accessor functions like distance_km are defined for these types, and these are necessarily different to those for geographic objects.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, distance_direct will calculate the straight-line distance in m between the event and station when in Cartesian coordinates:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = CartTrace(0, 1e-4, 1000)\nt.sta.x, t.sta.y, t.sta.z = 101, -35, 12\nt.evt.x, t.evt.y, t.evt.z = 12, 14, -100\ndistance_direct(t)","category":"page"},{"location":"manual/#Geometry-type-hierarchy-and-custom-geometry-types","page":"Manual","title":"Geometry type hierarchy and custom geometry types","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Geographic and Cartesian are subtypes of Seis.Position. This means that if you want to define your own coordinate system, you are able to do so by subtyping Seis.Position and you can then write methods taking a Trace{T, V, P} where {T, V, P}, where P is your new type.  These will replace the generic methods allowing special processing to be done in cases where the generic calculations need to be changed, without requiring writing duplicate methods where they do not. An example of a different coordinate system might be when stations have positions which vary in time.","category":"page"},{"location":"manual/#[Seis.Geographic](@ref)","page":"Manual","title":"Seis.Geographic","text":"","category":"section"},{"location":"manual/#[Seis.Cartesian](@ref)","page":"Manual","title":"Seis.Cartesian","text":"","category":"section"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/#Introduction","page":"Plotting","title":"Introduction","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Seis comes with plotting functionality which relies on Plots.  To create plots with Seis, first install Plots:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"import Pkg\nPkg.add(\"Plots\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Then whenever you wish to create plots for Trace objects, do","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> using Seis.Plot, Plots","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"This will bring the recipes into scope.","category":"page"},{"location":"plotting/#'Recipes'","page":"Plotting","title":"'Recipes'","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Seis.jl implements plotting via so-called 'recipes', based on the Plots plotting package. Recipes allow us to define plots for Traces without requiring the user to install Plots.  However, if Plots is installed and a using Plots command has been issued, then plots for Seis's objects can be easily created.","category":"page"},{"location":"plotting/#Plotting-functions","page":"Plotting","title":"Plotting functions","text":"","category":"section"},{"location":"plotting/#plot:-Single-trace-plots","page":"Plotting","title":"plot: Single-trace plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot creates a set of single-trace plots where the independent (x) axis is time, and the dependent (y) axis is the value of the trace, similar to simply plotting trace(t) against times(t).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"However, plot when applied to a single Trace or an AbstractArray{<:Trace} offers options to scale plots relatively, show pick times, and so on.","category":"page"},{"location":"plotting/#Examples","page":"Plotting","title":"Examples","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"1: A simple plot for a single trace, showing the picks.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plots\ndefault(fontfamily=\"Helvetica\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Seis, Seis.Plot, Plots\nt = sample_data()\nplot(t)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"2: Plot the vertical components for an earthquake with the distance    in km and station code labelled.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"t = sample_data(:regional)\nz = filter(x -> endswith(x.sta.cha, \"z\"), t)\nlabels = z.sta.sta .* \", ∆ = \" .* string.(round.(distance_km.(z), digits=1)) .* \"km\"\nplot(z, label=labels, sort=:dist)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"3: Same again, but showing the falloff in amplitude with distance by    setting all plots to have the same scale with the ylims option:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(z, label=labels, sort=:dist, ylims=:all)","category":"page"},{"location":"plotting/#Full-docstring","page":"Plotting","title":"Full docstring","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Seis.Plot.plot","category":"page"},{"location":"plotting/#Seis.Plot.plot","page":"Plotting","title":"Seis.Plot.plot","text":"plot(traces::AbstractArray{<:Seis.Trace}; kwargs...) -> ::Plots.Plot\nplot(trace::AbstractTrace; kwargs...) -> ::Plots.Plot\n\nPlot a set of traces as a set of separate wiggles, each with its own axes.\n\nAdditional options provided:\n\ndecimate: If false, do not decimate traces when plotting for speed.\nfill_down: Set the fill colour of the negative parts of traces.\nfill_up: Set the fill colour of the positive parts of traces. (Use line=nothing to turn off drawing of lines with the fill options.)\nlabel: Set to label for each trace.  This is placed in the top right corner.\nshow_picks: If false, do not plot picks.\nsort: Sort the traces according to one of the following:\n:dist: Epicentral distance\n:alpha: Alphanumerically by channel code\n::AbstractVector: According to the indices in a vector passed in, e.g. from a call to sortperm.\nylims: Control y-axis limits of traces:\n:all: All traces have same amplitude limits\n\n\n\n\n\n","category":"function"},{"location":"plotting/#section:-Record-sections","page":"Plotting","title":"section: Record sections","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"section plots a 'record section', or a set of traces where a trace's position on the y-axis is determined by some other information.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Typically record sections show traces against distance, but section supports arbitrary values or functions to place the traces.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To align traces, pass a set of values to the align keyword argument.","category":"page"},{"location":"plotting/#Examples-2","page":"Plotting","title":"Examples","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"1: Simple distance record section for the radial components of a    regional earthquake.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"t = sample_data(:regional)\ne, n, z = t[1:3:end], t[2:3:end], t[3:3:end]\nrotate_to_gcp!.(e, n)\nr, t = e, n\nsection(r)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"2: Same again, but with traces normalised so that the amplitudes    are more similar.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"section(r .|> normalise)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"3: Record section aligned on a set of picks stored with the key :A.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"t = sample_data(:array)\nsection(t, align=:A, xlim=(-10, 20))","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"4: Section, sorted by distance but equally spaced, where traces are    normalized to show how well the peaks are aligned, with the trace    amplitudes scaled down by half (using the zoom keyword), and    defining other Plots keywords to set the y-axis label.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"section(t .|> normalize, sortperm(t, by=distance_deg), align=:A,\n    xlim=(-10, 10), zoom=0.5, ylabel=\"Trace index, increasing distance\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"If you have installed SeisTau.jl, then adding predicted travel times and aligning on these becomes easy.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"5: Record section aligned on the predicted PKIKP arrival time, with    predicted times calculated using SeisTau, called via add_picks!.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using SeisTau\nadd_picks!.(t, \"PKIKP\")\nsection(t, align=:PKIKP, xlim=(-10, 10))","category":"page"},{"location":"plotting/#Full-docstring-2","page":"Plotting","title":"Full docstring","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Seis.Plot.section","category":"page"},{"location":"plotting/#Seis.Plot.section","page":"Plotting","title":"Seis.Plot.section","text":"section(traces, y_values=distance_deg.(traces); kwargs...) -> ::Plots.plot\n\nPlot a record section for a collection of Traces.  By default, the y-axis is epicentral distance in degrees, but specify one of the following for y_values to change this:\n\nA Function which will be applied to the traces, e.g., distance_km.\nA Symbol which corresponds to a field of the Traces' meta dictionary.\nA set of values (i.e., AbstractArray)\nOne of the following strings:\n\"index\" for trace index (i:length(traces))\n\nAdditional options provided via keyword arguments:\n\nabsscale: Set to a value to plot traces at some absolute scale.  This is             useful if one wants two or more sections to have the same scale.\nalign: Set to a String to align on the first pick with this name.          Set to an array of values to align on the value for each trace.          Set to a Symbol to use the pick of each trace with that key.\ndecimate: If false, do not perform downsampling of traces for plotting.          Defaults to true.\nfill_down: Set the fill colour of the negative parts of traces.\nfill_up: Set the fill colour of the positive parts of traces.          (Use line=nothing to turn off drawing of lines with the fill options.)\nmax_samples: Control the maximum number of samples to display at one time          in order to make plotting quicker.  Set decimate to false to turn          this off.\nshow_picks:  If true, add marks on the record section for each pick in the trace          headers.\nzoom: Set magnification scale for traces (default 1).\n\n\n\n\n\n","category":"function"},{"location":"plotting/#hodogram:-Particle-motion-plots","page":"Plotting","title":"hodogram: Particle motion plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Hododgrams, or particle motion plots, are parametric plots of two components of motion through time.  These can be plotted in Seis using hodogram.","category":"page"},{"location":"plotting/#Examples-3","page":"Plotting","title":"Examples","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"1: Hodogram of the horizontal components of an earthquake, windowed around    the P-wave arrival, showing the backazimuth to the event location,    and the particle motion and backazimuth label set to have different    colours using the linecolor option from Plots.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"t = e, n = sample_data(:regional)[1:2]\ncut!.(t, 50, 70)\nhodogram(e, n, backazimuth=true, linecolor=[:red :black])","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Seis.Plot.hodogram","category":"page"},{"location":"plotting/#Seis.Plot.hodogram","page":"Plotting","title":"Seis.Plot.hodogram","text":"hodogram(t1::Trace, t2::Trace; backazimuth=false) -> ::Plots.Plot\n\nPlot the particle motion for a pair of traces t1 and t2.\n\nThe two traces must have the same start time, length and sampling interval.\n\nIf backazimuth is true, plot the direction of the minor arc towards the event. Requires event and station coordinates to be present in headers.\n\n\n\n\n\n","category":"function"},{"location":"#[Seis.jl](https://github.com/anowacki/Seis.jl)","page":"Home","title":"Seis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An open, fast and flexible framework for analysing seismic data in Julia.","category":"page"},{"location":"#What-is-[Seis.jl](https://github.com/anowacki/Seis.jl)?","page":"Home","title":"What is Seis.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Seis is a Julia package for dealing with seismic data.  It allows you to read and write files, and perform processing on them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Even more importantly, it provides a flexible foundation on which to build your own processig workflows.  For example, the following packages build on Seis to provide extra functionality and form the Seis ecosystem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeisRequests downloads seismic data from remote servers direct to your machine.\nSeisSplit performs shear wave splitting analysis.\nBeamforming uses arrays of seismic recordings to stack data to detect signals.\nSeisTau calculates travel times of seismic waves through models of the Earth (and other planets).","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Seis can be added to your Julia environment like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] # Press ']' to enter the REPL Pkg mode\n(@v1.4)> add https://github.com/anowacki/Geodesics.jl https://github.com/anowacki/Seis.jl","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To check that your install is working correctly, you can run the package's tests by doing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.test(\"Seis\")","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"function-index/#Function-index","page":"Function index","title":"Function index","text":"","category":"section"},{"location":"function-index/#Public-types-and-functions","page":"Function index","title":"Public types and functions","text":"","category":"section"},{"location":"function-index/#Types","page":"Function index","title":"Types","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"Trace\nAbstractTrace\nCartTrace\nEvent\nCartEvent\nStation\nCartStation","category":"page"},{"location":"function-index/#Seis.Trace","page":"Function index","title":"Seis.Trace","text":"Trace\n\nEvenly-sampled time series recorded at a single seismic station.  The start time of the trace, in s, is in the b property, whilst the sampling interval, in s, is delta. The trace itself is accessed using the trace method, like trace(t).\n\nAll Traces are relative to the event time evt.time if it is defined, regardless of what the event is.  For example, evt.time could be the origin time of an earthquake, or a picked arrival time.\n\nThe trace then contains information about an associated Event in evt and the Station in sta.  picks holds a dictionary which contains pairs of pick times relative to the origin and names (which can be missing).  Access picks with the picks method, and add picks with add_pick!.\n\nThe meta Dict holds any other information about the trace.\n\nIf the event time is set, then the trace beginning time b is relative to this.\n\nFind the trace start time relative to the origin time using starttime. The absolute start time and date, if an origin time is set, is given by startdate.\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.AbstractTrace","page":"Function index","title":"Seis.AbstractTrace","text":"AbstractTrace\n\nAbstract type from which you should subtype if creating new types of traces.\n\nInterface\n\nnote: Note\nThe formal interface for AbstractTraces is still a work in progress and may change with a minor version increment.\n\nThe following methods should be defined for all AbstractTraces:\n\ntrace(t): Return the data for the trace.\ntimes(t): Return the time at each sample of t.\nstarttime(t): The time of the first sample.\nnsamples(t): The number of samples in t.\nBase.eltype(t): The element type of the data samples.\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.CartTrace","page":"Function index","title":"Seis.CartTrace","text":"CartTrace\n\nAlias for Trace where Event and Station coordinates are Seis.Cartesian rather than Seis.Geographic\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.Event","page":"Function index","title":"Seis.Event","text":"Event\n\nType containing information about a seismic event.  Fields lon and lat are epicentral location in °; dep is depth below the reference (e.g., sea level) in km. time is a Dates.DateTime giving the event origin date and time, while id is a string holding the event identifier. meta is a Dict holding any extra information about the event.\n\nMissing information is allowed and stored as missing.\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.CartEvent","page":"Function index","title":"Seis.CartEvent","text":"CartEvent{T}\n\nAlias for Event{T, Cartesian{T}} where T, representing an Event with Cartesian coordinates.\n\nThis type is useful for dispatch, allowing one to write methods which are only applicable when a Event has Cartesian coordinates.\n\nExample\n\njulia> using Geodesy\n\njulia> Geodesy.LLA(evt::CartEvent) = LLA(evt.x, evt.y, evt.z)\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.Station","page":"Function index","title":"Seis.Station","text":"Station\n\nStruct containing information about a seismic station.  Fields net, sta, loc and cha are the station, network, channel and location codes respectively, whilst lon and lat are the location in °.  Set station depth dep and elevation elev in m relative to the reference level.  The azimuth azi and inclination inc of the channel in ° are respectively measured from north to east, and downward from the vertical.  (E.g., a \"BHN\" channel typically will have a azi == 0 and inc == 90.)\n\nmeta is a Dict holding any extra information about the station or channel.\n\nMissing information is allowed and stored as missing.\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Seis.CartStation","page":"Function index","title":"Seis.CartStation","text":"CartStation{T} where T\n\nAlias for Station{T, Cartesian{T}} where T, representing a Station with Cartesian coordinates.\n\nThis type is useful for dispatch, allowing one to write methods which are only applicable when a Station has Cartesian coordinates.\n\nExample\n\nCreate a function which obtains the east-north-up coordinates of a Station\n\njulia> using Geodesy\n\njulia> Geodesy.ENU(sta::CartStation) = ENU(sta.x, sta.y, sta.z)\n\njulia> ENU(CartStation(x=1, y=2, z=3))\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Accessor-functions","page":"Function index","title":"Accessor functions","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"are_orthogonal\nchannel_code\ndates\nenddate\nendtime\nis_east\nis_north\nis_horizontal\nis_vertical\nnearest_sample\nnsamples\npicks\nstartdate\nstarttime\ntimes\ntrace","category":"page"},{"location":"function-index/#Seis.are_orthogonal","page":"Function index","title":"Seis.are_orthogonal","text":"are_orthogonal(sta1, sta2[, sta3]; tol) -> ::Bool\nare_orthogonal(t1, t2[, t3]; tol) -> ::Bool\n\nReturn true if Stations sta1 and sta2 are orthogonal to each other, or if sta1, sta2 and sta3 form a mutually-orthogonal set.\n\nThe comparison can also be performed on Traces in the second form.\n\nDirections are considered orthogonal if they differ from 90° by less than tol°, with a default value given by Seis._angle_tol.\n\nExamples\n\njulia> e, n, z = sample_data(:regional)[1:3];\n\njulia> are_orthogonal(e, n)\ntrue\n\njulia> are_orthogonal(e, n, z)\ntrue\n\njulia> are_orthogonal(Station(azi=0, inc=90), Station(azi=91, inc=90))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.channel_code","page":"Function index","title":"Seis.channel_code","text":"channel_code(t::Trace) -> code\nchannel_code(s::Station) -> code\n\nReturn the channel code for trace t or station s, in the form of \"⟨network⟩.⟨name⟩.⟨location⟩.⟨component⟩\".  Missing fields are left blank. The information is taken respectively from the net, sta, cha and loc fields of the Station.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.dates","page":"Function index","title":"Seis.dates","text":"dates(t) -> date_range\n\nReturn a date_range which contains the dates for each sample of t, so long as t.evt.time is defined.  If not, an error is thrown.\n\nN.B.  This function assumes that the sampling interval t.delta is representable as an integer number of milliseconds, and rounds it accordingly.  Dates.DateTimes have precision of 1 ms.  An error is thrown if t.delta < 1e-3 s.\n\nExample\n\njulia> t = sample_data();\n\njulia> dates(t)\n1981-03-29T10:39:06.66:10 milliseconds:1981-03-29T10:39:16.65\n\nSee also: times.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.enddate","page":"Function index","title":"Seis.enddate","text":"enddate(t) -> date\n\nReturn the date of the last sample of the trace t.\n\nN.B.  This function assumes that the sampling interval t.delta is representable as an integer number of milliseconds, and rounds it accordingly.  Dates.DateTimes have precision of 1 ms.  An error is thrown if t.delta < 1e-3 s.\n\nExample\n\njulia> t = sample_data(); t.evt.time\n1981-03-29T10:38:14\n\njulia> enddate(t)\n1981-03-29T10:39:16.65\n\nSee also: startdate.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.endtime","page":"Function index","title":"Seis.endtime","text":"endtime(t) -> time\n\nReturn the end time of trace t in seconds.\n\nExample\n\njulia> t = Trace(5, 1, 3); # 3 samples at 1 Hz, starting at 5 s\n\njulia> endtime(t)\n7.0\n\nSee also: starttime.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.is_east","page":"Function index","title":"Seis.is_east","text":"is_east(s::Station; tol) -> ::Bool\nis_east(t::AbstractTrace; tol) -> ::Bool\n\nReturn true if the trace t or station s is horizontal and points to the east.\n\nThe azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of tol°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to tol.\n\nSee also: is_north, is_vertical\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.is_north","page":"Function index","title":"Seis.is_north","text":"is_north(s::Station{T}; tol) where T -> ::Bool\nis_north(t::AbstractTrace; tol) -> ::Bool\n\nReturn true if the trace t is horizontal and points to the north.\n\nThe azimuth and inclination of the trace is compared to east and the horizontal within a tolerance of tol°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to tol.\n\nSee also: is_east, is_vertical\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.is_horizontal","page":"Function index","title":"Seis.is_horizontal","text":"is_horizontal(s::Station; tol)\nis_horizontal(t::AbstractTrace; tol) -> ::Bool\n\nReturn true if the trace t is horizontal (i.e., its inclination is 90° from the vertical), and false otherwise.\n\nThe inclination of the trace is compared to the horizontal within a tolerance of tol°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to tol.\n\nExamples\n\njulia> s = Station(azi=0, inc=90);\n\njulia> is_horizontal(s)\ntrue\n\njulia> t = sample_data();\n\njulia> is_horizontal(t)\nfalse\n\njulia> t.sta.inc\n0.0f0\n\nSee also: is_vertical, is_east, is_north.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.is_vertical","page":"Function index","title":"Seis.is_vertical","text":"is_vertical(s::Station{T}; tol=eps(T)) where T\nis_vertical(t::AbstractTrace; tol=eps(eltype(trace(t)))) -> ::Bool\n\nReturn true if the trace t is vertical (i.e., its inclination is 0°), and false otherwise.\n\nThe inclination of the trace is compared to the vertical within a tolerance of tol°.  The default is set to be appropriate for the floating-point type used for the station or trace, but can be overridden by passing a comparison to tol.\n\nExamples\n\njulia> s = Station(azi=0, inc=90);\n\njulia> is_vertical(s)\nfalse\n\njulia> t = sample_data();\n\njulia> is_vertical(t)\ntrue\n\nSee also: is_horizontal.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.nearest_sample","page":"Function index","title":"Seis.nearest_sample","text":"nearest_sample(t::AbstractTrace, time; inside=true) -> i\n\nReturn the index i of the nearest sample of the trace t to time seconds.\n\nIf inside is true (the default), return nothing when time lies outside the trace.  Set inside to false to instead return the first or last index when time is outside the trace.\n\nExamples\n\njulia> t = Trace(0, 1, rand(5)); # Trace starting at 0 s, 1 Hz sampling\n\njulia> nearest_sample(t, 2)\n3\n\njulia> nearest_sample(t, -1)\n\njulia> nearest_sample(t, -1, inside=false)\n1\n\n\n\n\n\nnearest_sample(t::AbstractTrace, datetime::DateTime; inside=true)\n\nForm of nearest_sample where datetime is given as absolute time.\n\nAn error is thrown if no origin time is specified for t.evt.time.\n\nExample\n\njulia> using Dates: DateTime, Second\n\njulia> t = sample_data();\n\njulia> nearest_sample(t, DateTime(1981, 03, 29, 10, 39, 7))\n35\n\njulia> nearest_sample(t, startdate(t) - Second(10)) # 10 s before the first sample\n\njulia> nearest_sample(t, startdate(t) -  Second(10), inside=false)\n1\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.nsamples","page":"Function index","title":"Seis.nsamples","text":"nsamples(t) -> n\n\nReturn the number of samples n in a trace t.\n\nExample\n\njulia> data = rand(4);\n\njulia> t = Trace(0, 1, data);\n\njulia> nsamples(t)\n4\n\n\n\n\n\nnsamples(t, b, e) -> n\n\nReturn the number of samples n in a trace t between times b and e seconds.\n\nThis function only counts samples that are strictly on or later than the b time, and before or on the e time.\n\nExample\n\njulia> t = Trace(0, 1, 25); # 25 samples from 0s to 24 s\n\njulia> nsamples(t, 3, 4.1)\n2\n\nSee also: nearest_sample.\n\n\n\n\n\nnsamples(t, start::DateTime, stop::DateTime) -> n\n\nReturn the number of samples n in a trace t between dates start and stop.\n\nExample\n\njulia> using Dates\n\njulia> t = Trace(10, 1, 20); # 20 samples from 10 to 30 s\n\njulia> t.evt.time = DateTime(3000)\n3000-01-01T00:00:00\n\njulia> nsamples(t, DateTime(3000), DateTime(3000) + Second(9))\n0\n\njulia> nsamples(t, DateTime(3000) + Second(20), DateTime(3000) + Second(22))\n3\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.picks","page":"Function index","title":"Seis.picks","text":"picks(t; sort=nothing) -> p::Vector{Tuple{<:AbstractString,<:AbstractFloat}}\n\nReturn a vector p of Seis.Picks, which contain pairs of pick times and names associated with the Trace t.\n\nThis can be iterated like:\n\njulia> t = Trace(0, 1, rand(10));\n\njulia> add_pick!.(t, (1,2), (\"P\",\"S\"));\n\njulia> for (time, name) in picks(t) @show time, name end\n(time, name) = (1.0, \"P\")\n(time, name) = (2.0, \"S\")\n\n\n\n\n\npicks(t, name::AbstractString; sort=:time) -> p\npicks(t, pattern::Regex; sort=:time) -> p\n\nReturn a vector p of pairs of pick names and times associated with the Trace t which either are exactly name or match the regular expression pattern.\n\nBy default, picks are returned in order of increasing time.  Use sort=:name to sort alphanumerically by name (where unnamed picks appear first).\n\nExample\n\njulia> t = Trace(0, 1, 2); t.picks.P = (1, \"Pn\"); t.picks.S = (1.8, \"S\");\n\njulia> t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:\n  :P => Seis.Pick{Float64}(time=1.0, name=\"Pn\")\n  :S => Seis.Pick{Float64}(time=1.8, name=\"S\")\n\njulia> picks(t, \"S\")\n1-element Array{Seis.Pick{Float64},1}:\n Seis.Pick{Float64}(time=1.8, name=\"S\")\n\njulia> picks(t, r\"^P\")\n1-element Array{Seis.Pick{Float64},1}:\n Seis.Pick{Float64}(time=1.0, name=\"Pn\")\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.startdate","page":"Function index","title":"Seis.startdate","text":"startdate(t) -> date\n\nReturn the date of the first sample of the trace t.\n\nN.B.  This function assumes that the sampling interval t.delta is representable as an integer number of milliseconds, and rounds it accordingly.  Dates.DateTimes have precision of 1 ms.  An error is thrown if t.delta < 1e-3 s.\n\nExample\n\njulia> t = sample_data(); t.evt.time\n1981-03-29T10:38:14\n\njulia> startdate(t)\n1981-03-29T10:39:06.66\n\nSee also: enddate.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.starttime","page":"Function index","title":"Seis.starttime","text":"starttime(t) -> time\n\nReturn the start time of trace t in seconds.\n\nExample\n\njulia> t = Trace(-3, 0.01, rand(20)) # Set start time to -3;\n\njulia> starttime(t)\n-3.0\n\nSee also: endtime.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.times","page":"Function index","title":"Seis.times","text":"times(t) -> range\n\nReturn the set of times range at which each sample of the trace t is defined.\n\nExample\n\njulia> t = sample_data();\n\njulia> times(t)\n52.66f0:0.01f0:62.65f0\n\nSee also: dates.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.trace","page":"Function index","title":"Seis.trace","text":"trace(t) -> data\n\nReturn an array data containing the values of the Trace t at each sampling point.  data is now a variable bound to ts values, and changing data will change t.  trace(t) may itself also be modified and the trace will be updated.\n\nnote: Note\nThe value returned by trace is a variable bound to an internal field of the trace.  Therefore, assigning another value to trace(t) or data will not update the values in t.  Instead, update the values in-place using the . operator (like data .= 1).  See examples below.\n\nnote: Note\nThe underlying data array holding the trace can be rebound by assigning to the trace's field t, but this is unsupported and may break in future.\n\nExamples\n\nRetrieving the data values for a trace, and modifying the first value.\n\njulia> t = sample_data();\n\njulia> data = trace(t)\n1000-element Array{Float32,1}:\n -0.09728001\n -0.09728001\n  ⋮\n -0.0768\n -0.0768\n\njulia> data[1] = 0;\n\njulia> trace(t)\n1000-element Array{Float32,1}:\n  0.0\n -0.09728001\n  ⋮\n -0.0768\n -0.0768\n\nSetting the data values for a new synthetic trace.\n\njulia> t = Trace(0, 0.01, 1000); # 1000-point, 100 Hz trace with random data\n\njulia> trace(t) .= sin.(π.*times(t));\n\njulia> trace(t)\n1000-element Array{Float64,1}:\n  0.0\n  0.03141075907812829\n  ⋮\n -0.06279051952931425\n -0.031410759078131116\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Setter-functions","page":"Function index","title":"Setter functions","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"add_pick!\nadd_picks!\nclear_picks!\norigin_time!\norigin_time","category":"page"},{"location":"function-index/#Seis.add_pick!","page":"Function index","title":"Seis.add_pick!","text":"add_pick!(t, time [, name=missing]) -> (time, name)\n\nAdd an arrival time pick to the Trace t, ensuring existing picks are not overwritten.\n\nIf name is not missing, then the key of this pick will be Symbol(name), unless another pick with the same key already exists.  In that case, the name will be appended with a number which increases until an available key is found.\n\nIf name is missing, then the pick is added to a numbered set of picks.\n\n(Direct manipulation of picks is easy: just do t.picks.PKP = (1001, \"PKP\") to set a picks with name \"PKP\", time 1001 s and key :PKP.)\n\nExample\n\njulia> t = Trace(0, 1, 2);\n\njulia> add_pick!.(t, [1, 2], [\"A\", missing]);\n\njulia> t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:\n  :A => Seis.Pick{Float64}(time=1.0, name=\"A\")\n  1  => Seis.Pick{Float64}(time=2.0, name=missing)\n\njulia> add_pick!(t, 4)\nSeis.Pick{Float64}(time=4.0, name=missing)\n\njulia> t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 3 entries:\n  :A => Seis.Pick{Float64}(time=1.0, name=\"A\")\n  2  => Seis.Pick{Float64}(time=4.0, name=missing)\n  1  => Seis.Pick{Float64}(time=2.0, name=missing)\n\njulia> t.picks.A\nSeis.Pick{Float64}(time=1.0, name=\"A\")\n\njulia> t.picks[1]\nSeis.Pick{Float64}(time=2.0, name=missing)\n\nSee also: Seis.Pick.\n\n\n\n\n\nadd_pick!(t, p::Pick, name=p.name) -> p\n\nAdd a travel time pick to the Trace t from a Seis.Pick.  By default, the pick name is used.\n\nExample\n\njulia> t1 = Trace(0, 1, 20); t2 = sample_data();\n\njulia> add_pick!(t1, t2.picks.A, \"A\")\nSeis.Pick{Float64}(time=53.67000198364258, name=\"A\")\n\njulia> t1.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 1 entry:\n  :A => Seis.Pick{Float64}(time=53.67000198364258, name=\"A\")\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.add_picks!","page":"Function index","title":"Seis.add_picks!","text":"add_picks!\n\nAdd picks to traces based on seismic phases' predicted arrival time.\n\nSeis does not itself implement seismic phase travel time computation. See SeisTau for one implementation which adds methods to add_pick!.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.clear_picks!","page":"Function index","title":"Seis.clear_picks!","text":"clear_picks!(t)\n\nRemove all picks associated with the Trace t.\n\nExample\n\njulia> t = sample_data();\n\njulia> picks(t)\n2-element Array{Seis.Pick{Float32},1}:\n Seis.Pick{Float32}(time=53.670002, name=missing)\n Seis.Pick{Float32}(time=60.980003, name=missing)\n\njulia> clear_picks!(t);\n\njulia> picks(t)\n0-element Array{Seis.Pick{Float32},1}\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.origin_time!","page":"Function index","title":"Seis.origin_time!","text":"origin_time!(t, time::DateTime; picks=true) -> t\n\nSet the origin time of the trace t and shift the start time of the trace (stored in its .b field) so that the absolute time of all samples remains the same.\n\norigin_time! will also shift all pick times so that they remain at the same absolute time.  Set picks=false to leave picks at the same time relative to the trace start time.\n\nIf t.evt.time is missing (i.e., unset), then it is simply set to time and no times are shifted.\n\nExample\n\njulia> using Dates\n\njulia> t = sample_data(); t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:\n  :F => Seis.Pick{Float32}(time=60.980003, name=missing)\n  :A => Seis.Pick{Float32}(time=53.670002, name=missing)\n\njulia> t.evt.time\n1981-03-29T10:38:14\n\njulia> origin_time!(t, t.evt.time + Second(1)); t.evt.time\n1981-03-29T10:38:15\n\njulia> t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float32}} with 2 entries:\n  :F => Seis.Pick{Float32}(time=59.980003, name=missing)\n  :A => Seis.Pick{Float32}(time=52.670002, name=missing)\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.origin_time","page":"Function index","title":"Seis.origin_time","text":"origin_time(t, time::DateTime; picks=true) -> t′\n\nReturn a copy to t where the event origin time is shifted to time.\n\nSee the in-place version origin_time! for more details.\n\n\n\n\n\norigin_time(t) -> ::Dates.DateTime\n\nReturn the origin time of the trace t, which is the point in time to which samples are referenced.  In this single-argument method, the trace t is unchanged.\n\nExample\n\njulia> t = sample_data();\n\njulia> origin_time(t)\n1981-03-29T10:38:14\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Geometry-functions","page":"Function index","title":"Geometry functions","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"azimuth\nbackazimuth\ndistance_deg\ndistance_direct\ndistance_km\nincidence","category":"page"},{"location":"function-index/#Seis.azimuth","page":"Function index","title":"Seis.azimuth","text":"azimuth(trace; sphere=false, flattening=Geodesics.F_WGS84) -> az\nazimuth(event, station; sphere=false, flattening=Geodesics.F_WGS84) -> az\n\nReturn the azimuth az from the event to the station (a seismic station) in degrees east from local north at the event for a trace.  Alternatively specify the event and station individually.\n\nOptionally specify the flattening of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If sphere is true, then flattening is set to zero and the calculation is performed on a sphere.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.backazimuth","page":"Function index","title":"Seis.backazimuth","text":"backazimuth(trace; flattening=0.0033528106718309896) -> baz\nbackazimuth(station, event; flattening=0.0033528106718309896) -> baz\n\nReturn the backazimuth baz from the station (a seismic station) to an event in degrees east from local north at the station for a trace.  Alternatively specify the station and event individually.\n\nOptionally specify the flattening of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If sphere is true, then flattening is set to zero and the calculation is performed on a sphere.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.distance_deg","page":"Function index","title":"Seis.distance_deg","text":"distance_deg(trace; sphere=false, flattening=0.0033528106718309896) -> Δ\ndistance_deg(station, event; sphere=false, flattening=0.0033528106718309896) -> Δ\ndistance_deg(event, station; sphere=false, flattening=0.0033528106718309896) -> Δ\n\nFor a trace or an event-station pair, return the epicentral angular distance Δ in degrees.\n\nOptionally specify the flattening of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.  If sphere is true, then flattening is set to zero and the calculation is performed on a sphere.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.distance_direct","page":"Function index","title":"Seis.distance_direct","text":"distance_direct(trace)\ndistance_direct(event, station)\ndistance_direct(station, event)\n\nFor a cartesian trace or event-station pair, return the straight-line distance between them in m.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.distance_km","page":"Function index","title":"Seis.distance_km","text":"distance_km(event, station; sphere=false, a=6378.137, flattening=0.0033528106718309896) -> d\n\nFor a geographic trace or event–station pair, return the epicentral surface distance d in km between them.\n\nOptionally specify the semimajor radius a in km and flattening of the ellipsoid of rotation on which this is computed, which defaults to that of the WGS84 ellipsoid.    If sphere is true, then flattening is set to zero and the calculation is performed on a sphere.\n\n\n\n\n\ndistance_km(event, station) -> d\n\nFor a cartesian trace or event-station pair, return the epicentral distance in km between them.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.incidence","page":"Function index","title":"Seis.incidence","text":"incidence(event, station) -> i\nincidence(trace) -> i\n\nReturn the angle of incidence i° between a cartesian event and station, or a cartesian trace.  The angle of incidence is defined downwards from the positive z (upward) direction.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Trace-operations","page":"Function index","title":"Trace operations","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"cut!\ncut\ndecimate!\ndecimate\ndifferentiate!\ndifferentiate\nenvelope!\nenvelope\nflip!\nflip\nintegrate!\nintegrate\nnormalise!\nnormalise\nnormalize!\nnormalize\nremove_mean!\nremove_mean\nremove_trend!\nremove_trend\nresample!\nresample\ntaper!\ntaper","category":"page"},{"location":"function-index/#Seis.cut!","page":"Function index","title":"Seis.cut!","text":"cut!(t, start, end; allowempty=false, warn=true) -> t\n\nCut a Trace t in place between start and end.  An error is thrown if either start or end are missing.\n\nAn error is thrown if the trace would be empty because either the end cut time is before the start of the trace, or the start cut is after the end, unless allowempty is true.\n\nBy default, a warning is shown if cut times lie outside the trace; set warn to false to turn this off.\n\nExample\n\njulia> t = Trace(0, 1, [0, 1, 2, 3, 4, 5]);\n\njulia> trace(cut!(t, 2, 4))\n3-element Array{Float64,1}:\n 2.0\n 3.0\n 4.0\n\n\n\n\n\ncut!(t, start_date, end_date; kwargs...) -> t\n\nCut a Trace t in place between dates start_date and end_date.\n\nExample\n\nCreate a trace starting at midnight on 1 January 3000, and cut to between 10 s and 1 minute after midnight:\n\njulia> using Dates: DateTime\n\njulia> t = Trace(0, 1, 100); # 1 Hz sampling for 100 s;\n\njulia> t.evt.time = DateTime(3000, 1, 1); # The year 3000;\n\njulia> cut!(t, DateTime(3000, 1, 1, 0, 0, 10), DateTime(3000, 1, 1, 0, 1, 0))\nSeis.Trace{Float64,Vector{Float64},Seis.Geographic{Float64}}:\n            b: 10.0\n        delta: 1.0\n GeogStation{Float64}:\n     sta.meta: Seis.SeisDict{Symbol, Any}()\n GeogEvent{Float64}:\n     evt.time: 3000-01-01T00:00:00\n     evt.meta: Seis.SeisDict{Symbol, Any}()\n Trace:\n        picks: 0\n         meta: \n\njulia> startdate(t), enddate(t)\n(DateTime(\"3000-01-01T00:00:10\"), DateTime(\"3000-01-01T00:01:00\"))\n\n\n\n\n\ncut!(t, pick1, offset1, pick2, offset; kwargs...) -> t\ncut!(t, pick, offset1, offset2; kwargs...) ->\n\nCut a trace t in place between offset1 s after the first pick pick1 and offset2 s after pick2.\n\nIn the second form, both offsets are relative to pick.\n\nThe values of pick1, pick2 and pick are passed to picks and so may be a Symbol (giving the key of the pick), a String (giving the pick name) or a Regex (which matches the pick name).\n\nExample\n\njulia> t = sample_data();\n\njulia> starttime(t), endtime(t)\n(52.66f0, 62.65f0)\n\njulia> cut!(t, :A, 0, :F, 1);\n\njulia> starttime(t), endtime(t)\n(53.67f0, 61.979996f0)\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.cut","page":"Function index","title":"Seis.cut","text":"cut(t, start, end; kwargs...) -> t′\ncut(t, start_date, end_date; kwargs...) -> t′\ncut(t, pick1, offset1, pick2, offset2; kwargs...) -> t′\ncut(t, pick, offset1, offset2; kwargs...) -> t′\n\nReturn a copy of the trace t cut between start and end s relative to the event origin.  You may also specify a start_date and end_date, or choose times offset1 and offset2 s relative to pick1 and pick2 respectively.  Both offset times may also be specified relative to one pick.\n\nSee also: cut!, picks.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.decimate!","page":"Function index","title":"Seis.decimate!","text":"decimate!(t, n; antialias=true) -> t\ndecimate(t, n; antialias=true) -> t′\n\nDecimate the trace t by removing all except every n points.  The sampling interval is increased n times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nBy default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.\n\nIf antialias is false, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.decimate","page":"Function index","title":"Seis.decimate","text":"decimate!(t, n; antialias=true) -> t\ndecimate(t, n; antialias=true) -> t′\n\nDecimate the trace t by removing all except every n points.  The sampling interval is increased n times.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nBy default, an antialiasing and decimation FIR filter is applied.  This may cause artifacts in the signal at the extremes of the trace.\n\nIf antialias is false, then no antialiasing filtering is applied during decimation. This means the decimated trace may contain spurious signals.\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.differentiate!","page":"Function index","title":"Seis.differentiate!","text":"differentiate!(t::Trace; points=2) -> t\ndifferentiate(t::Trace; points=2) -> t′\n\nDifferentiate the trace t by performing points-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nAvailable algorithms\n\npoints == 2: Two-point.  dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta. Non-central difference, so t.b is increased by half t.delta. The trace length is reduced by 1 samples.\npoints == 3: Three-point. dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta). Central difference.  t.b is increased by t.delta; the trace length is reduced by 2 samples.\npoints == 5: Five-point. dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta. Central difference.  t.b is increased by 2t.delta; npts reduced by 4.\n\nExample\n\njulia> t = Trace(0, 1, [0, 1, -1, 0]);\n\njulia> d = differentiate(t); trace(d)\n3-element Array{Float64,1}:\n  1.0\n -2.0\n  1.0\n\njulia> starttime(d)\n0.5\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.differentiate","page":"Function index","title":"Seis.differentiate","text":"differentiate!(t::Trace; points=2) -> t\ndifferentiate(t::Trace; points=2) -> t′\n\nDifferentiate the trace t by performing points-point finite differencing. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nAvailable algorithms\n\npoints == 2: Two-point.  dsdt.t[i] = (t.t[i+1] - t.t[i])/t.delta. Non-central difference, so t.b is increased by half t.delta. The trace length is reduced by 1 samples.\npoints == 3: Three-point. dsdt.t[i] = (t.t[i+1] - t.t[i-1])/(2 * t.delta). Central difference.  t.b is increased by t.delta; the trace length is reduced by 2 samples.\npoints == 5: Five-point. dsdt.t[i] = (2/3)*(t.t[i+1] - t.t[i-1])/t.delta - (1/12)*(t.t[i+2] - t.t[i-2])/t.delta. Central difference.  t.b is increased by 2t.delta; npts reduced by 4.\n\nExample\n\njulia> t = Trace(0, 1, [0, 1, -1, 0]);\n\njulia> d = differentiate(t); trace(d)\n3-element Array{Float64,1}:\n  1.0\n -2.0\n  1.0\n\njulia> starttime(d)\n0.5\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.envelope!","page":"Function index","title":"Seis.envelope!","text":"envelope!(t::Trace) -> t\nenvelope(t::Trace) -> t′\n\nReplace the trace t with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);\n\njulia> trace(envelope(t))\n8-element Array{Float64,1}:\n 0.10355339059327379\n 0.10355339059327379\n 0.6035533905932737\n 1.1680225577002512\n 1.1680225577002512\n 0.6035533905932737\n 0.10355339059327373\n 0.10355339059327379\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.envelope","page":"Function index","title":"Seis.envelope","text":"envelope!(t::Trace) -> t\nenvelope(t::Trace) -> t′\n\nReplace the trace t with its envelope. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [0, 0, 0, 1, -1, 0, 0, 0]);\n\njulia> trace(envelope(t))\n8-element Array{Float64,1}:\n 0.10355339059327379\n 0.10355339059327379\n 0.6035533905932737\n 1.1680225577002512\n 1.1680225577002512\n 0.6035533905932737\n 0.10355339059327373\n 0.10355339059327379\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.flip!","page":"Function index","title":"Seis.flip!","text":"flip!(t) -> t\nflip(t) -> t′\n\nReverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.\n\nThe t.sta must contain both azimuth and inclination information.\n\nIn the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s\n\njulia> t.sta.azi, t.sta.inc = 0, 90 # North horizontal component\n(0, 90)\n\njulia> flip!(t)\nSeis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:\n            b: 0.0\n        delta: 1.0\n Station{Float64,Seis.Geographic{Float64}}:\n      sta.cha: 180.0\n      sta.azi: 180.0\n      sta.inc: 90.0\n     sta.meta: Seis.SeisDict{Symbol,Any}()\n Event{Float64,Seis.Geographic{Float64}}:\n     evt.meta: Seis.SeisDict{Symbol,Any}()\n Trace:\n        picks: 0\n         meta: \n\njulia> trace(t)\n3-element Array{Float64,1}:\n -0.0\n -1.0\n -0.0\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.flip","page":"Function index","title":"Seis.flip","text":"flip!(t) -> t\nflip(t) -> t′\n\nReverse the direction of a trace so that it points the opposite way. This preserves the sense of the data; for example, a positive signal on an eastward-pointing channel becomes a negative signal on the flipped westward pointing channel.  Both before and after, the signal is positive eastwards.\n\nThe t.sta must contain both azimuth and inclination information.\n\nIn the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [0, 1, 0]); # Positive arrival at 1 s\n\njulia> t.sta.azi, t.sta.inc = 0, 90 # North horizontal component\n(0, 90)\n\njulia> flip!(t)\nSeis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:\n            b: 0.0\n        delta: 1.0\n Station{Float64,Seis.Geographic{Float64}}:\n      sta.cha: 180.0\n      sta.azi: 180.0\n      sta.inc: 90.0\n     sta.meta: Seis.SeisDict{Symbol,Any}()\n Event{Float64,Seis.Geographic{Float64}}:\n     evt.meta: Seis.SeisDict{Symbol,Any}()\n Trace:\n        picks: 0\n         meta: \n\njulia> trace(t)\n3-element Array{Float64,1}:\n -0.0\n -1.0\n -0.0\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.integrate!","page":"Function index","title":"Seis.integrate!","text":"integrate!(t::Trace, method=:trapezium) -> t\nintegrate(t::Trace, method=:trapezium) -> t′\n\nReplace t with its time-integral.  This is done by default using the trapezium rule. Use method=:rectangle to use the rectangle rule.\n\nIn the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nIf method==:trapezium (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.\n\nExample\n\njulia> t = Trace(0, 0.1, [0, 1, 1, 0]);\n\njulia> trace(integrate(t))\n3-element Array{Float64,1}:\n 0.05\n 0.15000000000000002\n 0.2\n\njulia> trace(integrate(t, :rectangle))\n4-element Array{Float64,1}:\n 0.0\n 0.1\n 0.2\n 0.2\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.integrate","page":"Function index","title":"Seis.integrate","text":"integrate!(t::Trace, method=:trapezium) -> t\nintegrate(t::Trace, method=:trapezium) -> t′\n\nReplace t with its time-integral.  This is done by default using the trapezium rule. Use method=:rectangle to use the rectangle rule.\n\nIn the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nIf method==:trapezium (the default), then the number of samples is reduced by one and the begin time is increased by half the sampling interval.\n\nExample\n\njulia> t = Trace(0, 0.1, [0, 1, 1, 0]);\n\njulia> trace(integrate(t))\n3-element Array{Float64,1}:\n 0.05\n 0.15000000000000002\n 0.2\n\njulia> trace(integrate(t, :rectangle))\n4-element Array{Float64,1}:\n 0.0\n 0.1\n 0.2\n 0.2\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.normalise!","page":"Function index","title":"Seis.normalise!","text":"normalise!(t::Trace, val=1) -> t\nnormalise(t::Trace, val=1) -> t′\n\nNormalise the trace t so that its maximum absolute amplitude is val. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nThis function can also be spelled normalize[!].\n\nExample\n\njulia> t = Trace(0, 0.1, [0, -1, 2]);\n\njulia> trace(normalise(t))\n3-element Array{Float64,1}:\n  0.0\n -0.5\n  1.0\n\njulia> trace(normalise(t, 2))\n3-element Array{Float64,1}:\n  0.0\n -1.0\n  2.0\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.normalise","page":"Function index","title":"Seis.normalise","text":"normalise!(t::Trace, val=1) -> t\nnormalise(t::Trace, val=1) -> t′\n\nNormalise the trace t so that its maximum absolute amplitude is val. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nThis function can also be spelled normalize[!].\n\nExample\n\njulia> t = Trace(0, 0.1, [0, -1, 2]);\n\njulia> trace(normalise(t))\n3-element Array{Float64,1}:\n  0.0\n -0.5\n  1.0\n\njulia> trace(normalise(t, 2))\n3-element Array{Float64,1}:\n  0.0\n -1.0\n  2.0\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#LinearAlgebra.normalize!","page":"Function index","title":"LinearAlgebra.normalize!","text":"normalise!(t::Trace, val=1) -> t\nnormalise(t::Trace, val=1) -> t′\n\nNormalise the trace t so that its maximum absolute amplitude is val. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nThis function can also be spelled normalize[!].\n\nExample\n\njulia> t = Trace(0, 0.1, [0, -1, 2]);\n\njulia> trace(normalise(t))\n3-element Array{Float64,1}:\n  0.0\n -0.5\n  1.0\n\njulia> trace(normalise(t, 2))\n3-element Array{Float64,1}:\n  0.0\n -1.0\n  2.0\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#LinearAlgebra.normalize","page":"Function index","title":"LinearAlgebra.normalize","text":"normalise!(t::Trace, val=1) -> t\nnormalise(t::Trace, val=1) -> t′\n\nNormalise the trace t so that its maximum absolute amplitude is val. In the first form, update the trace in place and return the trace. In the second form, return an updated copy.\n\nThis function can also be spelled normalize[!].\n\nExample\n\njulia> t = Trace(0, 0.1, [0, -1, 2]);\n\njulia> trace(normalise(t))\n3-element Array{Float64,1}:\n  0.0\n -0.5\n  1.0\n\njulia> trace(normalise(t, 2))\n3-element Array{Float64,1}:\n  0.0\n -1.0\n  2.0\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.remove_mean!","page":"Function index","title":"Seis.remove_mean!","text":"remove_mean!(t::Trace) -> t\nremove_mean(t::Trace) -> t′\n\nRemove the mean of trace t.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 0.01, [1, 1, 3, -1]);\n\njulia> trace(remove_mean(t))\n4-element Array{Float64,1}:\n  0.0\n  0.0\n  2.0\n -2.0\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.remove_mean","page":"Function index","title":"Seis.remove_mean","text":"remove_mean!(t::Trace) -> t\nremove_mean(t::Trace) -> t′\n\nRemove the mean of trace t.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 0.01, [1, 1, 3, -1]);\n\njulia> trace(remove_mean(t))\n4-element Array{Float64,1}:\n  0.0\n  0.0\n  2.0\n -2.0\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.remove_trend!","page":"Function index","title":"Seis.remove_trend!","text":"remove_trend!(t::Trace) -> t\nremove_trend(t::Trace) -> t′\n\nRemove the trend from t.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 0.2, [1, 2, 3, 4]);\n\njulia> trace(remove_trend(t))\n4-element Array{Float64,1}:\n -2.220446049250313e-16\n  0.0\n  0.0\n  4.440892098500626e-16\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.remove_trend","page":"Function index","title":"Seis.remove_trend","text":"remove_trend!(t::Trace) -> t\nremove_trend(t::Trace) -> t′\n\nRemove the trend from t.  In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 0.2, [1, 2, 3, 4]);\n\njulia> trace(remove_trend(t))\n4-element Array{Float64,1}:\n -2.220446049250313e-16\n  0.0\n  0.0\n  4.440892098500626e-16\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.resample!","page":"Function index","title":"Seis.resample!","text":"resample!(t::AbstractTrace; delta, n) -> t\nresample(t::AbstractTrace; delta, n) -> t′\n\nResample the trace t so that either the sampling interval becomes delta s, or its sampling rate is increased n times.  One of delta or n must be given.\n\nIn the first form, update the trace in place and return it.  In the second form, return an updated copy (t′).\n\nThe functions uses DSP.resample to perform the operation, which applies an antialias filter and 'additional operations' to prevent aliasing and minimise other artifacts.\n\nTo perform decimation without antialiasing, use decimate or decimate! with antialias=false.\n\nExample\n\njulia> t = Trace(0, 0.5, 1:4);\n\njulia> trace(resample(t, 3))\n\n\n\n\n\n","category":"function"},{"location":"function-index/#DSP.Filters.resample","page":"Function index","title":"DSP.Filters.resample","text":"resample!(t::AbstractTrace; delta, n) -> t\nresample(t::AbstractTrace; delta, n) -> t′\n\nResample the trace t so that either the sampling interval becomes delta s, or its sampling rate is increased n times.  One of delta or n must be given.\n\nIn the first form, update the trace in place and return it.  In the second form, return an updated copy (t′).\n\nThe functions uses DSP.resample to perform the operation, which applies an antialias filter and 'additional operations' to prevent aliasing and minimise other artifacts.\n\nTo perform decimation without antialiasing, use decimate or decimate! with antialias=false.\n\nExample\n\njulia> t = Trace(0, 0.5, 1:4);\n\njulia> trace(resample(t, 3))\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.taper!","page":"Function index","title":"Seis.taper!","text":"taper!(t::AbstractTrace, width=0.05, form=:hanning) -> t\ntaper(t::AbstractTrace, width=0.05, form=:hamming) -> t′\n\nApply a symmetric taper to each end of the data in trace t. form may be one of :hanning, :hamming or :cosine. width represents the fraction (at both ends) of the trace tapered, up to 0.5.\n\nIn the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);\n\njulia> trace(taper(t))\n6-element Array{Float64,1}:\n -0.0\n  0.49999999999999994\n -1.0\n  1.0\n -0.49999999999999994\n  0.0\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.taper","page":"Function index","title":"Seis.taper","text":"taper!(t::AbstractTrace, width=0.05, form=:hanning) -> t\ntaper(t::AbstractTrace, width=0.05, form=:hamming) -> t′\n\nApply a symmetric taper to each end of the data in trace t. form may be one of :hanning, :hamming or :cosine. width represents the fraction (at both ends) of the trace tapered, up to 0.5.\n\nIn the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nExample\n\njulia> t = Trace(0, 1, [-1, 1, -1, 1, -1, 1]);\n\njulia> trace(taper(t))\n6-element Array{Float64,1}:\n -0.0\n  0.49999999999999994\n -1.0\n  1.0\n -0.49999999999999994\n  0.0\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Filtering","page":"Function index","title":"Filtering","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"bandstop!\nbandstop\nbandpass!\nbandpass\nhighpass!\nhighpass\nlowpass!\nlowpass","category":"page"},{"location":"function-index/#Seis.bandstop!","page":"Function index","title":"Seis.bandstop!","text":"bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nbandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a bandreject filter to the trace t with stop band between frequencies f1 and f2 in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.bandstop","page":"Function index","title":"Seis.bandstop","text":"bandstop!(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nbandstop(t::Trace, f1, f2; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a bandreject filter to the trace t with stop band between frequencies f1 and f2 in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.bandpass!","page":"Function index","title":"Seis.bandpass!","text":"bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -> t\nbandpass(t::Trace, f1, f2; poles=2, twopass=false) -> t′\n\nApply a bandpass filter to the trace t between frequencies f1 and f2 in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.bandpass","page":"Function index","title":"Seis.bandpass","text":"bandpass!(t::Trace, f1, f2; poles=2, twopass=false) -> t\nbandpass(t::Trace, f1, f2; poles=2, twopass=false) -> t′\n\nApply a bandpass filter to the trace t between frequencies f1 and f2 in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.highpass!","page":"Function index","title":"Seis.highpass!","text":"highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nhighpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a highpass filter to the trace t with corner frequency f in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.highpass","page":"Function index","title":"Seis.highpass","text":"highpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nhighpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a highpass filter to the trace t with corner frequency f in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.lowpass!","page":"Function index","title":"Seis.lowpass!","text":"lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nlowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a lowpass filter to the trace t with corner frequency f in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.lowpass","page":"Function index","title":"Seis.lowpass","text":"lowpass!(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t\nlowpass(t::Trace, f; poles=2, twopass=false, kind=DSP.Butterworth(poles)) -> t′\n\nApply a lowpass filter to the trace t with corner frequency f in Hz. In the first form, update the trace in place and return it.  In the second form, return an updated copy.\n\nOptionally specify the number of poles of the filter, and whether a two-pass filter should be applied.  This doubles the effective number of poles, because both a forward and reverse pass occur.  This has the advantage of preserving the phase.\n\nSpecify the kind of filter by providing a kind from the DSP.Filters module. If doing so, the poles keyword argument is not used and the number of poles, ripple power, etc., should be specified when providing the filter kind.\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Trace-rotation","page":"Function index","title":"Trace rotation","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"rotate_through!\nrotate_through\nrotate_to_enz!\nrotate_to_enz\nrotate_to_gcp!\nrotate_to_gcp\nrotate_to_lqt!\nrotate_to_lqt\nrotate_to_azimuth_incidence!\nrotate_to_azimuth_incidence\nsort_traces_right_handed","category":"page"},{"location":"function-index/#Seis.rotate_through!","page":"Function index","title":"Seis.rotate_through!","text":"rotate_through!(t1::Trace, t2::Trace, phi[; tol]) -> t1, t2\n\nFor two traces t1 an t2 which are orthgonal, rotate them by phi° from t1 towards t2.  Note therefore that the order of the arguments matters and opposite rotations can be achieved by swapping t1 and t2.  Neither of the traces need to be horizontal.\n\nThis is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate from t2 to t1.\n\nTrace channel names are updated to contain the azimuth if both channels are horizontals.\n\nThe optional keyword argument tol specifies the angle in ° by which the traces must be orthogonal; see are_orthogonal.\n\nSee also: rotate_through, rotate_to_gcp!, rotate_to_azimuth_incidence!\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_through","page":"Function index","title":"Seis.rotate_through","text":"rotate_through!(t1::Trace, t2::Trace, phi[; tol]) -> t1, t2\n\nFor two traces t1 an t2 which are orthgonal, rotate them by phi° from t1 towards t2.  Note therefore that the order of the arguments matters and opposite rotations can be achieved by swapping t1 and t2.  Neither of the traces need to be horizontal.\n\nThis is a reference frame transformation (passive rotation) and hence particle motion will appear to rotate from t2 to t1.\n\nTrace channel names are updated to contain the azimuth if both channels are horizontals.\n\nThe optional keyword argument tol specifies the angle in ° by which the traces must be orthogonal; see are_orthogonal.\n\nSee also: rotate_through, rotate_to_gcp!, rotate_to_azimuth_incidence!\n\n\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_enz!","page":"Function index","title":"Seis.rotate_to_enz!","text":"rotate_to_enz!(t1, t2, t3[; tol]) -> e, n, z\n\nRotate three orthogonal traces t1, t2 and t3 in place so that they point east (e), north (n) and vertically (z).\n\ne, n and z are bindings to the same data as t1, t2 and t3, but they may not be returned in the same order as passed in if the original set of traces are not given as a right-handed set.\n\nSee also: rotate_through!, rotate_to_gcp!, rotate_to_lqt!\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_enz","page":"Function index","title":"Seis.rotate_to_enz","text":"rotate_to_enz(t1, t2, t3[; tol]) -> e, n, z\n\nCopying version of rotate_to_enz!.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_gcp!","page":"Function index","title":"Seis.rotate_to_gcp!","text":"rotate_to_gcp!(t1, t2; reverse=false, tol) -> t1, t2\n\nRotate the pair of traces t1 and t2 in place so that t1 points along the radial direction (the backazimuth plus 180°), and t2 is 90° clockwise from that.\n\nIf reverse is true, then t2 is rotated to be 90° anticlockwise from t1, so that the polarity is reversed.\n\nThe component names of the radial and transverse traces are updated to be 'R', and either 'T' or '-T' respectively for normal and reverse polarity, unless the component code is a valid SEED identifier which seems rotatable and matches for the traces; then the correct component name is used. (E.g., \"BHE\" and \"BHN\" become \"BHR\" and \"BHT\".)\n\nTraces must be orthogonal and horizontal.  The optional keyword argument tol specifies the angle in ° by which the traces must be orthogonal; see are_orthogonal.\n\nSee also: rotate_to_lqt!, rotate_to_azimuth_incidence!, rotate_to_enz!\n\n\n\n\n\nrotate_to_gcp!(t::AbstractArray{T}; kwargs...) -> t\n\nRotate pairs of traces in the array t so they are in the order [R1, T1, R2, T2, ...].\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_gcp","page":"Function index","title":"Seis.rotate_to_gcp","text":"rotate_to_gcp(t1, t2; reverse=false[, tol]) -> R, T\nrotate_to_gcp(t::AbstractArray{<:AbstractTrace}; reverse=false[, tol]) -> t′\n\nCopying version of rotate_to_gcp! which returns the radial R and transverse T traces in the first form, or pairs of radial and transverse traces in the modified array t′\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_lqt!","page":"Function index","title":"Seis.rotate_to_lqt!","text":"rotate_to_lqt!(t1, t2, t3; [tol]) -> L, Q, T\nrotate_to_lqt!(t1, t2, t3, incidence; [tol]) -> L, Q, T\nrotate_to_lqt!(t1, t2, t3, azimuth, incidence; [tol]) -> L, Q, T\n\nRotate the three traces t1, t2 and t3 in place, and return them in the order L, Q and T, forming a right-handed set.\n\nThe L trace records positive motion along the event-receiver direction, defined by the local azimuth at the receiver (i.e., backazimuth + 180°) and incidence angle (measured downwards away from the positive upwards direction).\n\nThe T direction is transverse to L, such that when looking along the direction towards the station, T is on the right and lies in the horizontal plane.\n\nThe Q direction is perpendicular to both, lying in the saggital plane, with some component in the vertical direction.\n\nIf azimuth and inclination are not passed in explicitly, then they are determined using the event-station geometry.  This is only possible for both for Traces in Cartesian geometry, since inclination is not well-determined in a geographic system.  Geographic-system traces (the default) must pass at least the inclination.  For the Cartesian case, we assume straight-line paths between event and receiver.\n\ntol specifies the angle in ° by which the traces must be orthogonal; see are_orthogonal\n\nnote: Note\nIf incidence is 0° or 90° (the direction is vertical), then the choice of Q and T is arbitrary and simply chosen such that Q points along the local azimuth.\n\nDiagram\n\nPlan view\n\n ⋆ (event)       North\n  `                ↑\n    `              |\n      `            |\n        `\n          ∇ (station)\n         ⊙ `\n      -  Q   `\n    ↙          ↘\n   T            L\n\nSide view\n\n                 Q\n                 ↑\n Up               |\n ↑                 |\n |                  |      __ → L\n |      (station)  ∇ ⊙__---\n             .__--   T\n        .__--\n    __--\n  ⋆ (event)\n\nExamples\n\njulia> e, n, z = sample_data(:regional)[1:3];\n\njulia> azi = azimuth(e) + 180\n216.85858118935954\n\njulia> inc = 30; # Determined from other calculation\n\njulia> l, q, t = rotate_to_lqt!(e, n, z, azi, inc)\n(Seis.Trace(.ELK..1: delta=0.025, b=-5.000015, nsamples=12000), Seis.Trace(.ELK..2: delta=0.025, b=-5.000015, nsamples=12000), Seis.Trace(.ELK..T: delta=0.025, b=-5.000015, nsamples=12000))\n\njulia> l.sta.azi, l.sta.inc, l.sta.cha\n(216.85858f0, 30.0f0, \"1\")\n\njulia> t.sta.cha\n\"T\"\n\njulia> l == e, q == n, t == z # Original traces are modified and returned in a possibly different order\n(true, true, true)\n\nSee also: rotate_through!, rotate_to_azimuth_incidence!, rotate_to_enz\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_lqt","page":"Function index","title":"Seis.rotate_to_lqt","text":"rotate_to_lqt(t1, t2, t3[, azimuth[, incidence]; tol) -> l, q, t\n\nCopying version of rotate_to_lqt!.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_azimuth_incidence!","page":"Function index","title":"Seis.rotate_to_azimuth_incidence!","text":"rotate_to_azimuth_incidence!(t1, t2, t3, azimuth, incidence[; tol]) -> x, y, z\n\nRotate a mutually-orthogonal set of traces t1, t2 and t3 such that the trace x points along the direction defined by azimuth, y points perpendicular to x and has components only in the direction along azimuth and the vertical; z is perpendicular to both and lies in the horizontal plane. x, y and z form a right-handed set and are commonly known as L, Q and T respectively.  (See rotate_to_lqt!.)\n\nNote that in this form, the underlying data and metadata in the input traces is altered, and the returned traces point to the same data as the input traces, but possibly in a different order.  Use rotate_to_azimuth_incidence to return copies of the traces and leave the original traces unmodified.\n\nSee also: rotate_to_azimuth_incidence!, rotate_to_gcp!, rotate_to_lqt!, rotate_through!\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.rotate_to_azimuth_incidence","page":"Function index","title":"Seis.rotate_to_azimuth_incidence","text":"rotate_to_azimuth_incidence(t1, t2, t3, azimuth, incidence[; tol]) -> x, y, z\n\nCopying version of rotate_to_azimuth_incidence.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.sort_traces_right_handed","page":"Function index","title":"Seis.sort_traces_right_handed","text":"sort_traces_right_handed(t1, t2, t3) -> x, y, z, perm\n\nSort the traces t1, t2 and t3 such that they form a right-handed set; requiring the traces to be mutually orthogonal.  The direction of x, y and z are arbitrary.  perm is a length-three tuple containing the indices (from 1 to 3) of the new order of traces, such that x is (t1, t2, t3)[perm[1]] and so on.\n\nExample\n\njulia> e, n, z = sample_data(:regional)[1:3];\n\njulia> e.sta.cha, n.sta.cha, z.sta.cha # Confirm the order\n(\"e\", \"n\", \"z\")\n\njulia> u, v, w, perm = Seis.sort_traces_right_handed(n, e, z); # A left-handed arrangement\n\njulia> [u, v, w].sta.cha\n3-element Vector{String}:\n \"n\"\n \"z\"\n \"e\"\n\njulia> [n, e, z][[perm...]] # Indexing by perm gives us the new order\n3-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:\n Seis.Trace(.ELK..n: delta=0.025, b=-5.000015, nsamples=12000)\n Seis.Trace(.ELK..z: delta=0.025, b=-5.000015, nsamples=12000)\n Seis.Trace(.ELK..e: delta=0.025, b=-5.000015, nsamples=12000)\n\n\n\n\n\n","category":"function"},{"location":"function-index/#IO","page":"Function index","title":"IO","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"read_mseed\nread_sac\nwrite_mseed\nwrite_sac\nSeis.SAC.SACTrace","category":"page"},{"location":"function-index/#Seis.read_mseed","page":"Function index","title":"Seis.read_mseed","text":"read_mseed(file; kwargs...) -> traces\nread_mseed(file, T; kwargs...) -> traces::Vector{T}\n\nRead a single miniseed file from disk and return a set of Traces.\n\nThe meta.mseed_file field of each trace contains the file name. \n\nOptionally specify the type of trace T <: AbstractTrace to read.  By default, T is Trace{Float64, Vector{Float32}, Seis.Geographic{Float64}}, since almost all seismic data stored in Miniseed format is single-precision, and because the sampling rate is stored at a 64-bit float in miniSEED files.\n\nExample\n\nRead a single file:\n\njulia> read_mseed(\"data.mseed\")\n\nRead a single file assuming a Cartesian geometry:\n\njulia> read_mseed(CartTrace{Float64, Vector{Float32}}, \"data.mseed\")\n\nHandling gapped/overlapped data\n\nWhen channels containing gaps or overlaps are encountered, they are split into multiple Traces as each Trace must be continuous and evenly sampled.  However, data quite often contain single-sample offsets which are later corrected, and so these are ignored by default.\n\nUse the keyword argument maximum_gap to control whether or not gaps cause new traces to be created.  See below for more details.\n\nKeyword arguments\n\nThe following keyword arguments can be passed to read_mseed:\n\nmaximum_gap: The maximum absolute gap length in s beyond which gaps are no longer tolerated in a single trace.  By default this is the sampling interval of the trace being read.\nnote: Note\nSet maximum_gap to 0 to always split miniseed files into separate traces at all gaps.\nverbose: An integer starting from 0 upwards indicating how much information about the reding process should be printed to the screen. The default (0) only produces output for errors and warnings.\n\n\n\nread_mseed(data::Vector{UInt8}[, T]; kwargs...) -> traces\n\nRead Miniseed data from memory, held as a set of bytes, optionally specifying the type T of traces to return.  Keyword arguments are the same as for reading from a file on disk.\n\n\n\n\n\nread_mseed(pattern, dir) -> ::Vector{<:Trace}\nread_mseed(pattern, dir, T) -> Vector{T}\n\nRead all files matching pattern in directory dir.\n\nSee Glob.glob for details of pattern matching.\n\nOptionally specify the type of trace T <: AbstractTrace to read.\n\nExample\n\nRead all files matching \"TA.*.BHZ.mseed\" in all directories within DATA which themselves match \"Event_??\":\n\njulia> read_mseed(\"Event_??/TA.*.BHZ.mseed\", \"DATA\")\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.read_sac","page":"Function index","title":"Seis.read_sac","text":"read_sac(file; terse=false, header_only=true) → ::Trace\n\nRead a single evenly-sampled SAC file and return a Trace.  If terse is true, then warn when auto-byteswapping files.  To read only SAC headers from files, returning an empty trace, set header_only to `true.\n\n\n\nread_sac(glob, dir; echo=true, header_only=false) → ::Vector{Trace}\n\nRead SAC files which match the patern glob in directory dir and return a set of Traces.  Add the file names to t.meta.file.  These are relative paths.\n\nFile names matching the pattern are shown unless echo is false.\n\n\n\nWhen reading SAC files, the following conventions are observed:\n\nThe event id is held in header KEVNM\nChannel ID is held in KCMPNM\nLocation ID is held in KHOLE\nIf O and the file origin time parameters are set, O is shifted to 0 time, and all time picks are adjusted.  This is similar to using the commands ch o gmt [date]; ch allt (0 - &1,o&) to set the origin in SAC.\nTime picks are added to the Trace picks.\n\nSAC headers which don't directly translate to Trace attributes are placed in the .meta field and have names prefixed by \"SAC_\".\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.write_mseed","page":"Function index","title":"Seis.write_mseed","text":"write_mseed(file, t; append=false, verbose=0, pubversion=1, record_length=nothing, version=2)\n\nWrite the data contained in thet to file on disk in miniSEED format.\n\nt may be either a single AbstractTrace, or an array of AbstractTraces.\n\nminiSEED files can contain data in (amongst others) in Float32, Float64 and Int32 format.  This function will use whatever precision or type the data in t have and attempt to write.  If for example you want to write a trace with a Float64 element type to a miniSEED file with element type Float32, you should first convert the trace using convert. (Note that since Seis does not support integer-valued trace data, it will not write 32-bit integer miniSEED files.)\n\nIf the trace does not have an origin time set, an error is thrown.\n\nKeyword arguments\n\nappend::Bool: If true, add the data in t to the end of any data already existing in file.  miniSEED files can contain multiples traces.\nverbose::Integer: Controls the verbosity of the miniSEED conversion and writing process.  Larger values of verbose cause more output to be produced.\npubversion::Integer: The publication version of data describes whether a set of data has been updated since being initially published.  Higher numbers correspond to records which supercede lower versions, which start at 1 (the default).\nrecord_length::Integer: The number of bytes used to write each miniSEED record.\nversion: The miniSEED file version to write.  Can be 2 (the default) or 3.\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.write_sac","page":"Function index","title":"Seis.write_sac","text":"write_sac(t, file; littleendian=false)\n\nWrite the Trace t to file in SAC format.\n\nKeys in the t.meta field which begin with SAC_ have their values written to the corresponding SAC field (e.g., t.meta.SAC_kuser0 is written to the KUSER0 header).  The user is responsible for ensuring that the values corresponding to these keys can be converted to the correct header type.  Note also that SAC_ meta fields override the equivalent Trace headers (e.g., t.sta.sta is equivalent to SAC_kstnm) and so one way to override the values in Trace headers is to set the SAC_ fields. Note that the header is lowercase (i.e., SAC_kstnm not SAC_KSTNM).\n\nTime picks with keys corresponding to SAC picks headers (A, F, and T0 to T9) are transferred, but other picks are not.\n\nIf t is in a Cartesian reference frame (i.e., its positions are given by CartEvent and CartStation), then the Cartesian station coordinates x, y and z are saved respectively to headers USER0, USER1 and USER2. Likewise, the event coordinates are saved respectively to USER3, USER4 and USER5.  Any information in meta fields SAC_user0 to SAC_user5 will overwrite this data.\n\nnote: Note\nThe convention on how non-geographic coordinates are written in SAC headers is not part of the API and may change at any time.  Saving non-standard information in SAC headers should be done explicitly by the user if this information is important.\n\nBy default, files are written to disk in bigendian format (MacSAC or SAC/BRIS convention).  Use littleendian=true to write in littleendian byte order (SAC/IRIS or SAC2000 convention).\n\n\n\n\n\n","category":"function"},{"location":"function-index/#Seis.SAC.SACTrace","page":"Function index","title":"Seis.SAC.SACTrace","text":"SACTrace(delta, npts, b=0.) -> ::SACTrace\n\nConstruct a composite type holding an evenly-spaced SAC time-series trace, where the trace is accessed through the field name t.  Supply the constant sampling interval delta in seconds, and the number of points in the trace t.  Optionally, specify the trace start time b in seconds.\n\nSACTrace(v::AbstractVector, delta, b=0.) -> ::SACTrace\n\nConstruct a SACTrace by supplying an array v, sampling interval delta and optionally the starting time.\n\nSACTrace(d::Vector{UInt8}, file=\"\"; swap=true, terse=false, check_npts=true) -> ::SACTrace\n\nConstruct a SACTrace from a raw array of bytes representing some data in SAC format. If swap is false, then non-native-endian files are not converted.  If terse is true, then warnings about swapping are not written.  If check_npts is false, then parts of files are read without error.\n\n\n\n\n\n","category":"type"},{"location":"function-index/#Example-data-sets","page":"Function index","title":"Example data sets","text":"","category":"section"},{"location":"function-index/","page":"Function index","title":"Function index","text":"sample_data","category":"page"},{"location":"function-index/#Seis.sample_data","page":"Function index","title":"Seis.sample_data","text":"sample_data() -> ::Trace\nsample_data(kind::Symbol) -> ::Array{Trace}\n\nReturn some sample data.\n\nWith no arguments, sample gives one trace from a local earthquake recorded in California.\n\nIn the second form, a set of traces is returned according to the table below:\n\nkind Description\n:local Livermore Valley, CA.  9 3-component stations\n:regional Nevada.  4 3-component stations\n:teleseism Mid-period recording of Eureka, CA event.  4 3-c stations\n:teleseisl Long-period recording of Eureka, CA event.  4 3-c stations\n:array Deep Fiji event.  60 vertical stations in the UK\n\n\n\n\n\n","category":"function"},{"location":"internal-index/#Developer-documentation","page":"Internals","title":"Developer documentation","text":"","category":"section"},{"location":"internal-index/","page":"Internals","title":"Internals","text":"This page lists internal functions and types which may change between minor releases of Seis, and hence are not part of the public API.","category":"page"},{"location":"internal-index/#Private-function-index","page":"Internals","title":"Private function index","text":"","category":"section"},{"location":"internal-index/#Private-types","page":"Internals","title":"Private types","text":"","category":"section"},{"location":"internal-index/","page":"Internals","title":"Internals","text":"Seis.Pick","category":"page"},{"location":"internal-index/#Seis.Pick","page":"Internals","title":"Seis.Pick","text":"Pick{T}\n\nA named arrival time which can be associated with a Trace.\n\nIf p is a Pick, then p.time gives the arrival time, and p.name gives its description.\n\nPicks can be iterated to retrieve the time and name in that order. Collections of Picks (such as those stored in the picks field of Traces) can have their elements assigned by automatic conversion from real numbers, tuples, or named tuples with fields time and name.\n\nArrays of Picks, which are stored in Traces, can be accessed using getproperty (.-access) and this returns arrays of times or names.\n\nExamples\n\nGetting and setting values\n\njulia> t = Trace(0, 1, 1)\nSeis.Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}}:\n            b: 0.0\n        delta: 1.0\n Station{Float64,Seis.Geographic{Float64}}:\n     sta.meta: Seis.SeisDict{Symbol,Any}()\n Event{Float64,Seis.Geographic{Float64}}:\n     evt.meta: Seis.SeisDict{Symbol,Any}()\n Trace:\n        picks: 0\n         meta: \n\njulia> t.picks.P = 1.2\n1.2\n\njulia> t.picks.S = 2.1, \"Sn\"\n(2.1, \"Sn\")\n\njulia> t.picks.S.time\n2.1\n\njulia> t.picks\nSeis.SeisDict{Union{Int64, Symbol},Seis.Pick{Float64}} with 2 entries:\n  :P => Seis.Pick{Float64}(time=1.2, name=missing)\n  :S => Seis.Pick{Float64}(time=2.1, name=\"Sn\")\n\nIteration\n\njulia> time, name = Seis.Pick(1, \"X\")\nSeis.Pick{Float64}(time=1.0, name=\"X\")\n\njulia> time, name\n(1.0, \"X\")\n\n\n\n\n\n","category":"type"},{"location":"internal-index/#Dictionaries","page":"Internals","title":"Dictionaries","text":"","category":"section"},{"location":"internal-index/","page":"Internals","title":"Internals","text":"Seis.SeisDict","category":"page"},{"location":"internal-index/#Seis.SeisDict","page":"Internals","title":"Seis.SeisDict","text":"SeisDict\n\nWrapper around Base.Dict which allows one to get or set values using the {get|set}property[!] syntax, i.e., .-access like dict.key. SeisDicts also differ in that missing is returned instead of throwing a KeyError when accessing a nonexistent key.  A key is removed if it is set to missing.\n\nExamples\n\njulia> dict = Seis.SeisDict(:a=>1)\nSeis.SeisDict{Any,Any} with 1 entry:\n  :a => 1\n\njulia> dict.a\n1\n\njulia> dict.b\nmissing\n\njulia> dict.a = missing\nmissing\n\njulia> dict\nSeis.SeisDict{Any,Any} with 0 entries\n\nAccess via getindex and setindex! (using []s) is still possible:\n\njulia> dict[:c] = 3\n3\n\njulia> dict[:c]\n3\n\njulia> dict[:c] = missing\nmissing\n\njulia> dict[:d] # No key with this value\nmissing\n\njulia> dict\nSeis.SeisDict{Any,Any} with 0 entries\n\nArrays of SeisDicts also define .-access and setting via broadcasting, so one may do:\n\njulia> d1 = Seis.SeisDict(:a=>1)\nSeis.SeisDict{Any,Any} with 1 entry:\n  :a => 1\n\njulia> d2 = deepcopy(d1); d2.a = 2;\n\njulia> d = [d1, d2]\n2-element Array{Seis.SeisDict{Any,Any},1}:\n Seis.SeisDict(:a => 1)\n Seis.SeisDict(:a => 2)\n\njulia> d.a\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"internal-index/#Position-in-space","page":"Internals","title":"Position in space","text":"","category":"section"},{"location":"internal-index/","page":"Internals","title":"Internals","text":"Seis.Position\nSeis.Geographic\nSeis.Cartesian","category":"page"},{"location":"internal-index/#Seis.Position","page":"Internals","title":"Seis.Position","text":"Position\n\nAbstract type of which other position types are subtypes. A Position specifies where in space an object is located.\n\nThe coordinates of a Position can be accessed via getproperty (e.g., p.x) or index (e.g., p[1]):\n\nExamples\n\njulia> p = Seis.Cartesian(x=1, y=2, z=3)\nSeis.Cartesian{Float64}(1.0, 2.0, 3.0)\n\njulia> p.x === p[1]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"internal-index/#Seis.Geographic","page":"Internals","title":"Seis.Geographic","text":"Geographic{T} <: Position\n\nA geographic position in spherical coordinates.  Accessible fields are:\n\nlon: Longitude (°)\nlat: Latitude (°)\ndep: Depth below the reference level (e.g., ellipsoid) (km)\n\nIt is recommended that for Stations, the dep field describes the depth of the sensor relative to sea level in km, so a station at 150 m elevation has a depth of –0.15 km.  Information about sensor burial depth should be held in the Event's meta field.\n\n\n\n\n\n","category":"type"},{"location":"internal-index/#Seis.Cartesian","page":"Internals","title":"Seis.Cartesian","text":"Cartesian{T} <: Position{T}\n\nA position in Cartesian coordinates.  Accessible fields are:\n\nx: X coordinate (m)\ny: Y coordinate (m)\nz: Z coordinate (m)\n\nSeis.jl's convention is that x and y are horizontal (usually with x being the local easting and y the local northing), and z is upwards (giving a right-handed system).  The units are m.\n\n\n\n\n\n","category":"type"},{"location":"internal-index/#Private-functions","page":"Internals","title":"Private functions","text":"","category":"section"},{"location":"internal-index/#'Getters'","page":"Internals","title":"'Getters'","text":"","category":"section"},{"location":"internal-index/","page":"Internals","title":"Internals","text":"Seis._angle_tol","category":"page"},{"location":"internal-index/#Seis._angle_tol","page":"Internals","title":"Seis._angle_tol","text":"_angle_tol(x) -> tol\n\nReturn an appropriate tolerance for x (a floating point type, AbstractTrace or Station) to use in comparisons of angular quantities in °.  Angles which are tol° or less apart can be considered identical.\n\n\n\n\n\n_angle_tol(x, y...) -> tol\n\nReturn an appropriate tolerance for a set of values or types x and y..., which is the maximum tolerance for all arguments.\n\n\n\n\n\n","category":"function"}]
}
