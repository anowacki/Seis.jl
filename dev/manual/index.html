<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Seis.jl documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Seis.jl documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Preamble"><span>Preamble</span></a></li><li><a class="tocitem" href="#Sample-data"><span>Sample data</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Getting-data-in"><span>Getting data in</span></a></li><li><a class="tocitem" href="#Creating-data-from-scratch"><span>Creating data from scratch</span></a></li><li><a class="tocitem" href="#Writing-data-out"><span>Writing data out</span></a></li><li><a class="tocitem" href="#Basic-processing"><span>Basic processing</span></a></li><li><a class="tocitem" href="#Accessing-raw-trace-data"><span>Accessing raw trace data</span></a></li><li><a class="tocitem" href="#Accessing-other-properties"><span>Accessing other properties</span></a></li><li><a class="tocitem" href="#Picks"><span>Picks</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../function-index/">Function index</a></li><li><a class="tocitem" href="../internal-index/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anowacki/Seis.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-manual"><a class="docs-heading-anchor" href="#User-manual">User manual</a><a id="User-manual-1"></a><a class="docs-heading-anchor-permalink" href="#User-manual" title="Permalink"></a></h1><p>This section describes how to use Seis to perform various basic processing operations on seismic data.</p><h2 id="Preamble"><a class="docs-heading-anchor" href="#Preamble">Preamble</a><a id="Preamble-1"></a><a class="docs-heading-anchor-permalink" href="#Preamble" title="Permalink"></a></h2><p>The examples in this manual all assume that you have first used the module like so:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Seis</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Sample-data"><a class="docs-heading-anchor" href="#Sample-data">Sample data</a><a id="Sample-data-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-data" title="Permalink"></a></h2><p>Seis comes with a small selection of sample data which will be used for the examples in this manual.  See the help for <a href="../function-index/#Seis.sample_data"><code>sample_data</code></a> for details.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>Working with Seis requires understanding a little bit about the types it uses.  Fundamentally, there are four important types:</p><ul><li><a href="../function-index/#Seis.Trace"><code>Trace</code></a>s, which contain</li><li><a href="../function-index/#Seis.Station"><code>Station</code></a>s and</li><li><a href="../function-index/#Seis.Event"><code>Event</code></a>s; and also</li><li><a href="../function-index/#Seis.FourierTrace"><code>FourierTrace</code></a>s, which a frequency-domain <code>Trace</code>s.</li></ul><p>Each of these types have fields which either must contain data, or allow data to be <a href="https://docs.julialang.org/en/v1/manual/missing/#missing-1"><code>missing</code></a>.</p><h3 id="Traces"><a class="docs-heading-anchor" href="#Traces"><code>Trace</code>s</a><a id="Traces-1"></a><a class="docs-heading-anchor-permalink" href="#Traces" title="Permalink"></a></h3><p>A <code>Trace</code> holds a single continuous record of evenly-sampled data. As such, it cannot contain gaps or overlaps.  It may be referenced to an absolute start time, and by convention all times of day in Seis are <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>. Equally, however, a trace may have no absolute reference time.</p><p>Traces have a small number of fields which are directly accessible by users:</p><ul><li><code>delta</code> is the samping interval (1 / sampling rate) in s;</li><li><code>b</code> is the start time of the trace, relative to any absolute time if any;</li><li><code>sta</code> is a <a href="#Stations"><code>Station</code></a> holding information about the site where this recording was made;</li><li><code>evt</code> is an <a href="#Events"><code>Event</code></a> holding information about any event related to this recording, such as an earthquake;</li><li><code>picks</code> holds a set of times of importance such as arrival picks; and</li><li><code>meta</code> holds any other information.</li></ul><p>None of these fields can be <code>missing</code>.</p><p>To access the data stored in a trace, use the <a href="../function-index/#Seis.trace"><code>trace</code></a> function to return the underlying array.</p><p>The user-accessible fields can be retrieved or modified as usual for composite types:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # A trace starting a 0 s with sampling interval 1 s made of 100 random samples
       t = Trace(0, 1, rand(100))
       # Update the sampling interval to 0.1 s</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Trace{Float64,Vector{Float64},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 1.0
 GeogStation{Float64}:
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float64}:
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 0
         meta:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.delta = 0.1</code><code class="nohighlight hljs ansi" style="display:block;">0.1</code></pre><h4 id="Mutability"><a class="docs-heading-anchor" href="#Mutability">Mutability</a><a id="Mutability-1"></a><a class="docs-heading-anchor-permalink" href="#Mutability" title="Permalink"></a></h4><p><code>Trace</code>s are mutable.  This means that the values they hold can be changed by the user at will.  It is often useful to copy a trace after you have performed an operation on it.  Thoughout Seis, as with Julia generally, functions which modify a <code>Trace</code> have an exclamation mark (<code>!</code>) at the end of their name.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Trace</code>s are &#39;parameterised&#39; on the type of floating point numbers they use, the type of data storage, and the geometry in which they are defined (i.e., either in geographic or Cartesian coordinates). A <code>Trace</code> is technically a <code>Trace{T, V, P} where {T, V, P}</code>, where <code>T</code> is the number type used, <code>V</code> is the type of vector holding the trace data, and <code>P</code> is the geometry type. This is why a trace has a scary-looking type like <code>Trace{Float32, Array{Float32, 1}, Seis.Geographic{Float32}}</code>. You only need to deal with these type parameters if you want to change these defaults.  See <a href="#Geometry">Geometry</a> for more information.</p></div></div><h3 id="Collections-of-Traces"><a class="docs-heading-anchor" href="#Collections-of-Traces">Collections of <code>Trace</code>s</a><a id="Collections-of-Traces-1"></a><a class="docs-heading-anchor-permalink" href="#Collections-of-Traces" title="Permalink"></a></h3><p>In Seis, methods are usually written to accept <code>Trace</code>s.  There is no special container for several traces; instead you can use <code>Array</code>s of traces just as you would any other collection of types.</p><p>For example, to find the epicentral distance between the earthquake and a number of recordings of it at different stations, you could use Julia&#39;s broadcasting feature to call the <a href="../function-index/#Seis.distance_deg"><code>distance_deg</code></a> function on each <code>Trace</code>.  (Note that the <code>sample_data</code> function returns a simple <code>Vector{Trace}</code> of recordings.)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = sample_data(:array)</code><code class="nohighlight hljs ansi" style="display:block;">60-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:
 Seis.Trace(.ABA..SHZ: delta=0.05, b=996.73, nsamples=6002)
 Seis.Trace(.APA..SHZ: delta=0.05, b=996.87, nsamples=6002)
 Seis.Trace(.AWI..SHZ: delta=0.05, b=996.86, nsamples=6002)
 Seis.Trace(.BBH..SHZ: delta=0.05, b=996.34, nsamples=6002)
 Seis.Trace(.BBO..SHZ: delta=0.05, b=996.51, nsamples=6002)
 Seis.Trace(.BDL..SHZ: delta=0.05, b=995.81, nsamples=6002)
 Seis.Trace(.BTA..SHZ: delta=0.05, b=995.8, nsamples=6002)
 Seis.Trace(.BWH..SHZ: delta=0.05, b=996.1, nsamples=6002)
 Seis.Trace(.CRA..SHZ: delta=0.05, b=999.85, nsamples=6002)
 Seis.Trace(.CSF..SHZ: delta=0.05, b=995.22, nsamples=6002)
 ⋮
 Seis.Trace(.WCB..SHZ: delta=0.05, b=987.78, nsamples=6002)
 Seis.Trace(.WME..SHZ: delta=0.05, b=987.89, nsamples=6002)
 Seis.Trace(.WPM..SHZ: delta=0.05, b=987.8, nsamples=6002)
 Seis.Trace(.XAL..SHZ: delta=0.05, b=994.08, nsamples=6002)
 Seis.Trace(.XDE..SHZ: delta=0.05, b=994.94, nsamples=6002)
 Seis.Trace(.YEL..SHZ: delta=0.05, b=996.79, nsamples=6002)
 Seis.Trace(.YLL..SHZ: delta=0.05, b=988.17, nsamples=6002)
 Seis.Trace(.YRC..SHZ: delta=0.05, b=988.03, nsamples=6002)
 Seis.Trace(.YRE..SHZ: delta=0.05, b=988.29, nsamples=6002)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(t)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Trace{Float32, Vector{Float32}, Geographic{Float32}}} (alias for Array{Trace{Float32, Array{Float32, 1}, Seis.Geographic{Float32}}, 1})</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(t)</code><code class="nohighlight hljs ansi" style="display:block;">Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; distance_deg.(t)</code><code class="nohighlight hljs ansi" style="display:block;">60-element Vector{Float64}:
 150.77944621926457
 151.35719900309945
 150.82652363302728
 148.47569756225323
 148.85352129112246
 148.80415824159704
 148.7142987502766
 148.39243651154584
 153.2137411026592
 149.1411942978774
   ⋮
 150.1093711892705
 150.11145961826915
 150.27951531203723
 148.7781191276318
 149.06873665863068
 143.1208080990685
 150.3761745994614
 150.2332219600003
 150.51277958154284</code></pre><p>To find the nearest station, you could write the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t[argmin(distance_deg.(t))].sta</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Station{Float32,Seis.Geographic{Float32}}:
             lon: -1.083
             lat: 60.5509
             dep: missing
             net: missing
             sta: YEL
             loc: missing
             cha: SHZ
            elev: missing
             azi: 0.0
             inc: 0.0
            meta:</code></pre><h3 id="Stations"><a class="docs-heading-anchor" href="#Stations"><code>Station</code>s</a><a id="Stations-1"></a><a class="docs-heading-anchor-permalink" href="#Stations" title="Permalink"></a></h3><p><code>Station</code>s define a stationary point in space where a recording was made. They have the following fields which you can access and modify:</p><ul><li><code>net</code>, <code>sta</code>, <code>loc</code> and <code>cha</code> are used respectively for the network, station, channel and location names of a single recording channel. They correspond to the <a href="http://www.fdsn.org/pdf/SEEDManual_V2.4_Appendix-A.pdf">SEED channel naming convention</a>, but all can be <code>missing</code>.</li><li><code>lon</code>, <code>lat</code> and <code>elev</code> are the longitude and latitude (in °, positive eastwards and northwards) of the station, whilst <code>elev</code> is the elevation above sea level in m.</li><li><code>azi</code> and <code>inc</code> together define the orientation of the channel; that is, in which spatial direction positive values point.  <code>azi</code> is the local azimuth in ° measured clockwise from north, whilst <code>inc</code> is the local inclination in ° measured from the vertical downwards.  For seismic data, vertical channels will have <code>inc == 0</code> and <code>azi == 0</code>, whilst horizontal channels will have <code>inc == 90</code> and <code>azi == 0</code> for north and <code>azi == 90</code> for east.</li><li><code>meta</code> holds all other information.</li></ul><p>See <a href="#Geometry">Geometry</a> for more details on other coordinate systems in which objects can be placed in Seis.</p><h3 id="Events"><a class="docs-heading-anchor" href="#Events"><code>Event</code>s</a><a id="Events-1"></a><a class="docs-heading-anchor-permalink" href="#Events" title="Permalink"></a></h3><p>An <code>Event</code> marks the source of a <code>Trace</code>.  Typically, it represents the source of energy for a recording, or it may simply indicate the start time of a section of data with no energy source implied.</p><p><code>Event</code>s have the following accessible fields, all of which can be <code>missing</code>:</p><ul><li><code>time</code> is a <code>Dates.DateTime</code> giving an absolute date and time in UTC against which a <code>Trace</code>&#39;s <code>b</code> field (beginning time) is relative. For an earthquake or other source of energy, it should be the origin time of that event.</li><li><code>lon</code>, <code>lat</code> and <code>dep</code> are the longitude and latitude (in °) and depth (in km) of any identified source for the data, such as an earthquake.</li><li><code>id</code> is a <code>String</code> giving some identifying information about an event, and could be a catalogue ID or otherwise.</li><li><code>meta</code> holds all other information.  By convention, the following fields in <code>meta</code> might be used:<ul><li><code>mag</code> holds an event magnitude;</li><li><code>quakeml</code> holds information about an event in QuakeML form, if any;</li><li><code>catalog</code> gives the name of the catalogue for this event.</li></ul></li></ul><h3 id="FourierTraces"><a class="docs-heading-anchor" href="#FourierTraces"><code>FourierTrace</code>s</a><a id="FourierTraces-1"></a><a class="docs-heading-anchor-permalink" href="#FourierTraces" title="Permalink"></a></h3><p>A <code>FourierTrace</code> is a frequency-domain version of its corresponding <code>Trace</code>. Usually you convert an existing <code>Trace</code> to the time domain by calling <a href="../function-index/#AbstractFFTs.fft-Tuple{Trace}"><code>fft</code></a>, and then call <a href="../function-index/#AbstractFFTs.ifft-Tuple{FourierTrace}"><code>ifft</code></a> to convert it back.  Because <code>Trace</code>s have to have real-valued data, a <code>FourierTrace</code>&#39;s data is a one-sided Fourier transform.  You access the underlying data in the same way as for <code>Traces</code>, with <a href="../function-index/#Seis.trace"><code>trace</code></a>.</p><p>A <code>FourierTrace</code>&#39;s public fields are:</p><ul><li><code>delta</code>, giving the frequency spacing of the data;</li><li><code>evt</code>, giving the event associated with the recording;</li><li><code>sta</code>, giving station information; and</li><li><code>meta</code> holding other things.</li></ul><p><code>evt</code>, <code>sta</code> and <code>meta</code> are brought across from a <code>FourierTrace</code>&#39;s originating <code>Trace</code> when constructed in the usual way with <code>fft</code>, and they are passed back to the new trace when calling <code>ifft</code>.</p><p><code>FourierTrace</code>s have the following accessor methods of their own:</p><ul><li><a href="../function-index/#Seis.frequencies"><code>frequencies</code></a> gives the frequencies of each data point;</li><li><a href="../function-index/#Seis.nfrequencies"><code>nfrequencies</code></a> gives the number of data points; and</li><li><a href="../function-index/#Seis.nsamples"><code>nsamples</code></a> gives the number of data points in the equivalent time-domain <code>Trace</code>.</li></ul><p>Because a <code>FourierTrace</code> retains enough information about the starting trace to turn it back, you can also call <a href="../function-index/#Seis.starttime"><code>starttime</code></a> on a <code>FourierTrace</code>.</p><h2 id="Getting-data-in"><a class="docs-heading-anchor" href="#Getting-data-in">Getting data in</a><a id="Getting-data-in-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-data-in" title="Permalink"></a></h2><p>Data can be loaded into Julia via a number of means:</p><ul><li><p>Reading data from disk in SAC or miniSEED format.</p><p>For this use either <a href="../function-index/#Seis.read_sac"><code>read_sac</code></a> or <a href="../function-index/#Seis.read_mseed"><code>read_mseed</code></a>.</p><p>To read a single file, use the one-argument form:</p><pre><code class="nohighlight hljs">julia&gt; t1 = read_sac(&quot;single_file.sac&quot;)
Seis.Trace{Float32,Array{Float32,1},Seis.Geographic{Float32}}:
           b: 52.66
       delta: 0.01
Station{Float32,Seis.Geographic{Float32}}:
     sta.lon: -120.0
     sta.lat: 48.0
     sta.sta: CDV
     sta.azi: 0.0
     sta.inc: 0.0
    sta.meta: Seis.SeisDict{Symbol,Any}()
Event{Float32,Seis.Geographic{Float32}}:
     evt.lon: -125.0
     evt.lat: 48.0
     evt.dep: 0.0
    evt.time: 1981-03-29T10:38:14
      evt.id: K8108838
    evt.meta: Seis.SeisDict{Symbol,Any}()
Trace:
       picks: 2
        meta: SAC_lpspol =&gt; true
              SAC_nevid =&gt; 0
              SAC_iftype =&gt; 1
              file =&gt; &quot;../test/test_data/seis.sac&quot;
              SAC_idep =&gt; 50
              SAC_iztype =&gt; 9
              SAC_lcalda =&gt; true
              SAC_unused18 =&gt; false
              SAC_lovrok =&gt; true
              SAC_norid =&gt; 0
              SAC_ievtyp =&gt; 42

julia&gt; t2 = read_mseed(&quot;file.mseed&quot;)
2-element Array{Trace{Float32,Array{Float32,1},Seis.Geographic{Float32}},1}:
 Seis.Trace(GB.CWF..BHZ: delta=0.02, b=0.0, nsamples=3000)
 Seis.Trace(GB.CWF..HHZ: delta=0.01, b=0.0, nsamples=6000)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SAC files can contain only one single continuous data channel, whilst miniSEED files can contain more than one, and so an array of <code>Trace</code>s are returned.</p></div></div><p>Reading several files using a globbing pattern:</p><pre><code class="nohighlight hljs">julia&gt; read_sac(&quot;Event_*/*Z.sac&quot;, &quot;DATA&quot;)</code></pre></li><li><p>Downloading data from a remote server.</p><p>For this, install and use <a href="https://github.com/anowacki/SeisRequests.jl">SeisRequests</a>.</p><pre><code class="nohighlight hljs">julia&gt; using SeisRequests

julia&gt; t = get_data(code=&quot;IU.ANMO.00.BH?&quot;, starttime=&quot;2018-02-02&quot;, endtime=&quot;2018-02-02T01:00:00&quot;) # an hour of data
[ Info: Request status: Successful request, results follow
3-element Array{Trace{Float64,Array{Float64,1},Seis.Geographic{Float64}},1}:
 Seis.Trace(IU.ANMO.00.BH1: delta=0.05, b=0.0, nsamples=72000)
 Seis.Trace(IU.ANMO.00.BH2: delta=0.05, b=0.0, nsamples=72000)
 Seis.Trace(IU.ANMO.00.BHZ: delta=0.05, b=0.0, nsamples=72000)</code></pre></li></ul><h2 id="Creating-data-from-scratch"><a class="docs-heading-anchor" href="#Creating-data-from-scratch">Creating data from scratch</a><a id="Creating-data-from-scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-data-from-scratch" title="Permalink"></a></h2><p><a href="../function-index/#Seis.Trace"><code>Trace</code></a>s can be constructed using the constructors.  For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 0</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; delta = 0.01</code><code class="nohighlight hljs ansi" style="display:block;">0.01</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = randn(1000)</code><code class="nohighlight hljs ansi" style="display:block;">1000-element Vector{Float64}:
 -0.3580380467142083
 -0.6333203453701011
 -0.43580353881409917
 -0.025001510157255283
  2.6181942606666015
 -1.1890192037554619
 -1.3549889411430287
 -0.10237674839829895
  0.20436711067954969
 -1.2553945304617253
  ⋮
  0.8805502067266953
 -0.43313727663605844
 -0.33598130544535154
 -0.7767738045099631
 -0.18086299724804253
  0.7996085082713768
 -0.9461315592721664
  0.801432748863351
 -0.10101604626793084</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = Trace(b, delta, data) # Fill trace with data already available</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Trace{Float64,Vector{Float64},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 0.01
 GeogStation{Float64}:
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float64}:
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 0
         meta:</code></pre><h2 id="Writing-data-out"><a class="docs-heading-anchor" href="#Writing-data-out">Writing data out</a><a id="Writing-data-out-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-data-out" title="Permalink"></a></h2><p>Seis currently supports writing in SAC and miniSEED format, using respectively the <a href="../function-index/#Seis.write_sac"><code>write_sac</code></a> and <a href="../function-index/#Seis.write_mseed"><code>write_mseed</code></a> functions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = sample_data()</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Trace{Float32,Vector{Float32},Seis.Geographic{Float32}}:
            b: 52.66
        delta: 0.01
 GeogStation{Float32}:
      sta.lon: -120.0
      sta.lat: 48.0
      sta.sta: CDV
      sta.azi: 0.0
      sta.inc: 0.0
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float32}:
      evt.lon: -125.0
      evt.lat: 48.0
      evt.dep: 0.0
     evt.time: 1981-03-29T10:38:14
       evt.id: K8108838
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 2
         meta: SAC_lpspol =&gt; true
               SAC_nevid =&gt; 0
               SAC_iftype =&gt; 1
               file =&gt; &quot;/home/runner/work/Seis.jl/Seis.jl/src/../data/seis.sac&quot;
               SAC_idep =&gt; 50
               SAC_iztype =&gt; 9
               SAC_lcalda =&gt; true
               SAC_unused18 =&gt; false
               SAC_lovrok =&gt; true
               SAC_norid =&gt; 0
               SAC_ievtyp =&gt; 42</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; write_sac(t, &quot;outfile.sac&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">4000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; write_mseed(&quot;outfile.mseed&quot;, t)</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>Note that miniSEED files can contain several traces, and so you can also pass an array of traces to <code>write_mseed</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = sample_data(:local)</code><code class="nohighlight hljs ansi" style="display:block;">27-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:
 Seis.Trace(.CALE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CALN..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CALZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CAOE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CAON..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CAOZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDAE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDAN..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDAZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CDVE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 ⋮
 Seis.Trace(.CVAE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVAN..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVAZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVLE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVLN..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVLZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVYE..e: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVYN..n: delta=0.01017683, b=-7.690632, nsamples=3933)
 Seis.Trace(.CVYZ..z: delta=0.01017683, b=-7.690632, nsamples=3933)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; write_mseed(&quot;local_data.mseed&quot;, t)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: nanoseconds must be in the range 0 - 999999</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Trace</code>s written in miniSEED format must have their <code>.evt.time</code> field set, since this is required in the file format.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>miniSEED files do not contain any information about the station or event.  The only information saved is the station network, station, location and channel codes and the start date of the first sample.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The order of arguments (file name and trace object) is different between <code>write_mseed</code> and <code>write_sac</code> for legacy reasons.  In a future major update the functions will all have the same order as <code>Base.write</code> (i.e., file name or <code>IO</code> object first, then trace object).</p></div></div><p>Seis supports reading and writing only the header part of SAC files:</p><ul><li>To read just headers, use <code>read_sac(file; header_only=true)</code>.</li><li>To write just headers, use <a href="../function-index/#Seis.write_sac_header"><code>write_sac_header</code></a>.</li></ul><p>miniSEED files can be read with only headers using <code>read_mseed(file; header_only=true)</code>.</p><h2 id="Basic-processing"><a class="docs-heading-anchor" href="#Basic-processing">Basic processing</a><a id="Basic-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-processing" title="Permalink"></a></h2><p>Once read in or obtained some other way, data can be processed in a number of ways.</p><p>Note that, as mentioned above (<a href="#Mutability">Mutability</a>), traces can be modified in place, or copies taken when processing steps are applied.  Modifying in place is usually faster as it does not involve copying all the information, but it is often more convenient to copy traces as well.  For this reason, there is always a modifying version of a function (ending in <code>!</code>), and a copying version, without.</p><ul><li>Cut the data to a certain window, in either relative time, absolute time, or relative to a time pick, with <a href="../function-index/#Seis.cut"><code>cut</code></a> or <a href="../function-index/#Seis.cut!"><code>cut!</code></a>.</li><li>Decimate the data, with or without an antialiasing filter (<a href="../function-index/#Seis.decimate"><code>decimate</code></a>, <a href="../function-index/#Seis.decimate!"><code>decimate!</code></a>).</li><li>Remove the mean value of the trace with <a href="../function-index/#Seis.remove_mean"><code>remove_mean</code></a> or <a href="../function-index/#Seis.remove_mean!"><code>remove_mean!</code></a>.</li><li>Remove a linear trend in the data with <a href="../function-index/#Seis.remove_trend"><code>remove_trend</code></a> or <a href="../function-index/#Seis.remove_trend!"><code>remove_trend!</code></a>.</li><li>Taper the signal with <a href="../function-index/#Seis.taper"><code>taper</code></a> or <a href="../function-index/#Seis.taper!"><code>taper!</code></a>.</li><li>Filter the data, performing a low-pass (<a href="../function-index/#Seis.lowpass"><code>lowpass</code></a>, <a href="../function-index/#Seis.lowpass!"><code>lowpass!</code></a>), high-pass (<a href="../function-index/#Seis.highpass"><code>highpass</code></a>, <a href="../function-index/#Seis.highpass!"><code>highpass!</code></a>), band-pass (<a href="../function-index/#Seis.bandpass"><code>bandpass</code></a>, <a href="../function-index/#Seis.bandpass!"><code>bandpass!</code></a>) or band-stop (<a href="../function-index/#Seis.bandstop"><code>bandstop</code></a>, <a href="../function-index/#Seis.bandstop!"><code>bandstop!</code></a>) filter.  For each, an acausal version of the filter can be obtained by passing the <code>twopass=true</code> option.</li><li>Differentiate (<a href="../function-index/#Seis.differentiate"><code>differentiate</code></a>, <a href="../function-index/#Seis.differentiate!"><code>differentiate!</code></a>) or integrate (<a href="../function-index/#Seis.integrate"><code>integrate</code></a>, <a href="../function-index/#Seis.integrate!"><code>integrate!</code></a>) the trace.</li><li>Normalise the data to a certain value with <a href="../function-index/#LinearAlgebra.normalize"><code>normalize</code></a> or <a href="../function-index/#LinearAlgebra.normalize!"><code>normalize!</code></a> (or <a href="../function-index/#Seis.normalise"><code>normalise</code></a> for us Brits).</li><li>Take the envelope of a trace with <a href="../function-index/#Seis.envelope"><code>envelope</code></a> or <a href="../function-index/#Seis.envelope!"><code>envelope!</code></a>.</li><li>Change the trace sampling interval with <a href="../function-index/#DSP.Filters.resample"><code>resample</code></a> or <a href="../function-index/#Seis.resample!"><code>resample!</code></a>.</li><li>Merge multiple traces with the same channel code together with <a href="../function-index/#Base.merge!-Tuple{AbstractTrace, AbstractArray{&lt;:AbstractTrace}}"><code>merge!</code></a> and <a href="@ref"><code>merge</code></a>.</li></ul><p>In addition, sets of traces can be rotated:</p><ul><li><a href="../function-index/#Seis.rotate_through"><code>rotate_through</code></a> and <a href="../function-index/#Seis.rotate_through!"><code>rotate_through!</code></a> rotate a pair of traces by a certain angle.</li><li><a href="../function-index/#Seis.rotate_to_gcp"><code>rotate_to_gcp</code></a> and <a href="../function-index/#Seis.rotate_to_gcp!"><code>rotate_to_gcp!</code></a> rotate pairs to radial (pointing away from the source at the station) and transverse (90° clockwise from this) components.</li><li><a href="../function-index/#Seis.rotate_to_lqt"><code>rotate_to_lqt</code></a> and <a href="../function-index/#Seis.rotate_to_lqt!"><code>rotate_to_lqt!</code></a> rotate triplets of orthogonal compontents to longitudinal (L), transverse (T) and Q (orthogonal to the others) orientations.</li><li><a href="../function-index/#Seis.rotate_to_azimuth_incidence"><code>rotate_to_azimuth_incidence</code></a> and <a href="../function-index/#Seis.rotate_to_azimuth_incidence!"><code>rotate_to_azimuth_incidence!</code></a> rotate triplets of orthogonal traces to arbitrary orientations.</li></ul><p>All of the above will use trace header information (coordinate of the event and station, and channel orientations) to automatically compute the directions if possible.</p><h2 id="Accessing-raw-trace-data"><a class="docs-heading-anchor" href="#Accessing-raw-trace-data">Accessing raw trace data</a><a id="Accessing-raw-trace-data-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-raw-trace-data" title="Permalink"></a></h2><p>Beyond these basic functions, <code>Trace</code>s are designed to be used to build your own processing workflows on top.  For example, shear wave splitting analysis can be done with <a href="https://github.com/anowacki/SeisSplit.jl">SeisSplit</a> and array processing with <a href="https://github.com/anowacki/Beamforming.jl">Beamforming</a>.</p><p>To access the raw trace, use the <a href="../function-index/#Seis.trace"><code>trace</code></a> function, which returns the data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = Trace(0, 0.1, [1, 2, 3, 4, 5])</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Trace{Float64,Vector{Float64},Seis.Geographic{Float64}}:
            b: 0.0
        delta: 0.1
 GeogStation{Float64}:
     sta.meta: Seis.SeisDict{Symbol, Any}()
 GeogEvent{Float64}:
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 0
         meta:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = trace(t)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0
 5.0</code></pre><p>As is usual with Julia, <code>data</code> is a variable bound to the same object as the underlying data of the trace <code>t</code>.  Modifying <code>data</code> will also modify the values in <code>t</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data[1] = 0 # Set the first point to be zero</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; trace(t) # Note the first point is now 0</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 0.0
 2.0
 3.0
 4.0
 5.0</code></pre><p><code>data</code> can be <a href="https://docs.julialang.org/en/v1/base/collections/#Base.empty!"><code>empty!</code></a>d, or <a href="https://docs.julialang.org/en/v1/base/collections/#Base.push!"><code>push!</code></a>ed or <a href="https://docs.julialang.org/en/v1/base/collections/#Base.append!"><code>append!</code></a>ed to, and so on—it is simply a vector of data points.</p><h2 id="Accessing-other-properties"><a class="docs-heading-anchor" href="#Accessing-other-properties">Accessing other properties</a><a id="Accessing-other-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-other-properties" title="Permalink"></a></h2><h3 id="Times"><a class="docs-heading-anchor" href="#Times">Times</a><a id="Times-1"></a><a class="docs-heading-anchor-permalink" href="#Times" title="Permalink"></a></h3><p>The first sample of a trace <code>t</code> occurs at time <code>t.b</code>, and each sample is <code>t.delta</code> seconds after the previous one.  Therefore, each sample of the trace has a time, and this array (actually a subtype of <code>AbstractRange</code>) can be obtained with <a href="../function-index/#Seis.times"><code>times</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; times(t)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.1:0.4</code></pre><p>For consistency, the start and end times of a trace are given by <a href="../function-index/#Seis.starttime"><code>starttime</code></a> and <a href="../function-index/#Seis.endtime"><code>endtime</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; starttime(t), endtime(t)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 0.4)</code></pre><p>All these times are relative to the event date if that is set.  If it is, then <a href="../function-index/#Seis.startdate"><code>startdate</code></a> and <a href="../function-index/#Seis.enddate"><code>enddate</code></a> give the start and end date of the trace in UTC:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Dates</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.evt.time = DateTime(2013, 5, 24, 5, 44, 49, 880) # Set the origin time</code><code class="nohighlight hljs ansi" style="display:block;">2013-05-24T05:44:49.880</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; startdate(t), enddate(t)</code><code class="nohighlight hljs ansi" style="display:block;">(Dates.DateTime(&quot;2013-05-24T05:44:49.880&quot;), Dates.DateTime(&quot;2013-05-24T05:44:50.280&quot;))</code></pre><p>Like before, we can get a set of dates for every sample with <a href="../function-index/#Seis.dates"><code>dates</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dates(t)</code><code class="nohighlight hljs ansi" style="display:block;">Dates.DateTime(&quot;2013-05-24T05:44:49.880&quot;):Dates.Millisecond(100):Dates.DateTime(&quot;2013-05-24T05:44:50.280&quot;)</code></pre><p>There should be 5 values here, since we gave the trace a set of 5 data points. <a href="../function-index/#Seis.nsamples"><code>nsamples</code></a> tells us this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nsamples(t)</code><code class="nohighlight hljs ansi" style="display:block;">5</code></pre><p>The closest sample to a certain time or date can be found with <a href="../function-index/#Seis.nearest_sample"><code>nearest_sample</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nearest_sample(t, 0.11)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nearest_sample(t, DateTime(2013, 5, 24, 5, 44, 50))</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><h2 id="Picks"><a class="docs-heading-anchor" href="#Picks">Picks</a><a id="Picks-1"></a><a class="docs-heading-anchor-permalink" href="#Picks" title="Permalink"></a></h2><p>Seis allows you to assign arbitrary time picks to a <code>Trace</code> and use these in flexible ways.</p><p>Picks are simply markers which label a certain point in time with a label. They are useful for marking particular phase arrivals and for other purposes.  All picks in Seis are relative to the origin time for the trace if any.  So if a trace&#39;s <code>starttime</code> is 3 s and a pick is at 4 s, the pick points to a time 1 s after the trace starts.</p><p>Picks have two fields: <code>time</code> and <code>name</code>.  <code>time</code> is the time in seconds after zero time, which is the event time if set.  <code>name</code> may be a <code>String</code> such as <code>&quot;PcP&quot;</code>, or <code>missing</code> if no name is needed for this pick.</p><h3 id="Getting-picks"><a class="docs-heading-anchor" href="#Getting-picks">Getting picks</a><a id="Getting-picks-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-picks" title="Permalink"></a></h3><p>Picks are accessible in the <code>picks</code> field of a trace:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = sample_data();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 2 entries:
  :F =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)</code></pre><p>You can see that there are two picks defined: one at 53.67 s with key <code>:A</code>, and one at 60.98 s with key <code>:F</code>.  Each pick is associated with a key, which can be a <code>Symbol</code>, or an <code>Int</code>.  Picks with a <code>Symbol</code> key are named picks and can be accessed in two ways.</p><p>You can access a named pick with dot notation if you know the literal key:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks.A</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Pick{Float32}(time=53.670002, name=missing)</code></pre><p>You can also use <code>getindex</code> or <code>[]</code> notation to access a named pick using a variable bound to a <code>Symbol</code> or a literal value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks[:A]</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Pick{Float32}(time=53.670002, name=missing)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pickkey = :A; t.picks[pickkey]</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Pick{Float32}(time=53.670002, name=missing)</code></pre><p>For any pick, access its time and name like so:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks.A.time, t.picks.A.name</code><code class="nohighlight hljs ansi" style="display:block;">(53.670002f0, missing)</code></pre><h3 id="Setting-picks"><a class="docs-heading-anchor" href="#Setting-picks">Setting picks</a><a id="Setting-picks-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-picks" title="Permalink"></a></h3><p>Setting picks is done similarly.  To add a named pick with name <code>:S</code>, time 2 s and name <code>&quot;Sg&quot;</code>, you can do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks.S = 2, &quot;Sg&quot;</code><code class="nohighlight hljs ansi" style="display:block;">(2, &quot;Sg&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 3 entries:
  :F =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)
  :S =&gt; Seis.Pick{Float32}(time=2.0, name=&quot;Sg&quot;)</code></pre><p>Or, you can use <code>setindex!</code> (<code>[]</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks[:S] = 2.5</code><code class="nohighlight hljs ansi" style="display:block;">2.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 3 entries:
  :F =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)
  :S =&gt; Seis.Pick{Float32}(time=2.5, name=missing)</code></pre><p>Note that the <code>:S</code> pick is overwritten.  Note also here that by not providing a name for the pick, its name defaults to <code>missing</code>.</p><p>Picks can also be set using <a href="../function-index/#Seis.add_picks!"><code>add_picks!</code></a>, which can take a <code>Dates.DateTime</code> to set a pick in absolute time rather than a time relative to the trace origin.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Dates</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_pick!(t, DateTime(&quot;1981-03-29T10:39:10&quot;), &quot;Coffee time&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)</code></pre><h3 id="Removing-picks"><a class="docs-heading-anchor" href="#Removing-picks">Removing picks</a><a id="Removing-picks-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-picks" title="Permalink"></a></h3><p>Remove picks as usual for <code>Dict</code>-like collections of things, with <code>delete!</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; delete!(t.picks, :S)</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 3 entries:
  :F                    =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A                    =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)
  Symbol(&quot;Coffee time&quot;) =&gt; Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 3 entries:
  :F                    =&gt; Seis.Pick{Float32}(time=60.980003, name=missing)
  :A                    =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)
  Symbol(&quot;Coffee time&quot;) =&gt; Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)</code></pre><p>You can also use the special method for the <code>picks</code> field of setting a pick to <code>missing</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks.F = missing</code><code class="nohighlight hljs ansi" style="display:block;">missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 2 entries:
  :A                    =&gt; Seis.Pick{Float32}(time=53.670002, name=missing)
  Symbol(&quot;Coffee time&quot;) =&gt; Seis.Pick{Float32}(time=56.0, name=&quot;Coffee time&quot;)</code></pre><p>Remove all picks with the <a href="../function-index/#Seis.clear_picks!"><code>clear_picks!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; clear_picks!(t)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Union{Int64, Symbol}, Seis.Pick{Float32}}()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}}()</code></pre><h3 id="Arrays-of-picks"><a class="docs-heading-anchor" href="#Arrays-of-picks">Arrays of picks</a><a id="Arrays-of-picks-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-of-picks" title="Permalink"></a></h3><p>Because <code>t.picks</code> is a special type of <code>Dict</code> (a <a href="../internal-index/#Seis.SeisDict"><code>Seis.SeisDict</code></a>), we can also access the <code>time</code> and <code>name</code> fields of sets of picks easily.</p><p>For example, if dealing with a set of stations where we have a pick for each, we can extract the vector of all pick times simply:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = sample_data(:array)</code><code class="nohighlight hljs ansi" style="display:block;">60-element Vector{Trace{Float32, Vector{Float32}, Seis.Geographic{Float32}}}:
 Seis.Trace(.ABA..SHZ: delta=0.05, b=996.73, nsamples=6002)
 Seis.Trace(.APA..SHZ: delta=0.05, b=996.87, nsamples=6002)
 Seis.Trace(.AWI..SHZ: delta=0.05, b=996.86, nsamples=6002)
 Seis.Trace(.BBH..SHZ: delta=0.05, b=996.34, nsamples=6002)
 Seis.Trace(.BBO..SHZ: delta=0.05, b=996.51, nsamples=6002)
 Seis.Trace(.BDL..SHZ: delta=0.05, b=995.81, nsamples=6002)
 Seis.Trace(.BTA..SHZ: delta=0.05, b=995.8, nsamples=6002)
 Seis.Trace(.BWH..SHZ: delta=0.05, b=996.1, nsamples=6002)
 Seis.Trace(.CRA..SHZ: delta=0.05, b=999.85, nsamples=6002)
 Seis.Trace(.CSF..SHZ: delta=0.05, b=995.22, nsamples=6002)
 ⋮
 Seis.Trace(.WCB..SHZ: delta=0.05, b=987.78, nsamples=6002)
 Seis.Trace(.WME..SHZ: delta=0.05, b=987.89, nsamples=6002)
 Seis.Trace(.WPM..SHZ: delta=0.05, b=987.8, nsamples=6002)
 Seis.Trace(.XAL..SHZ: delta=0.05, b=994.08, nsamples=6002)
 Seis.Trace(.XDE..SHZ: delta=0.05, b=994.94, nsamples=6002)
 Seis.Trace(.YEL..SHZ: delta=0.05, b=996.79, nsamples=6002)
 Seis.Trace(.YLL..SHZ: delta=0.05, b=988.17, nsamples=6002)
 Seis.Trace(.YRC..SHZ: delta=0.05, b=988.03, nsamples=6002)
 Seis.Trace(.YRE..SHZ: delta=0.05, b=988.29, nsamples=6002)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t[1].picks # Picks of the first trace</code><code class="nohighlight hljs ansi" style="display:block;">Seis.SeisDict{Union{Int64, Symbol}, Seis.Pick{Float32}} with 2 entries:
  :A  =&gt; Seis.Pick{Float32}(time=1134.08, name=missing)
  :T1 =&gt; Seis.Pick{Float32}(time=137.35, name=missing)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.picks.A.time # Times of all A picks for all traces</code><code class="nohighlight hljs ansi" style="display:block;">60-element Vector{Float32}:
 1134.08
 1135.62
 1134.61
 1128.9
 1130.0
 1129.5
 1129.3
 1128.4
 1141.9
 1130.67
    ⋮
 1132.43
 1132.69
 1133.04
 1129.33
 1130.14
 1114.24
 1133.36
 1132.82
 1133.64</code></pre><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>Seis allows you to have traces defined in any coordinate system you like. By default, it provides two main types:</p><ul><li><code>Geographic</code>, where coordinates are given as longitudes and latitudes in °, and depths in km below sea level, and</li><li><code>Cartesian</code>, where coordinates are <span>$x$</span>, <span>$y$</span> and <span>$z$</span> in a right-handed system and each is given in m.  Conventionally in Seis, <span>$x$</span> is a local easting and <span>$y$</span> is a local northing, meaning <span>$z$</span> is the upwards direction and usually <span>$z$</span> is <span>$0$</span> at sea level or the local reference level.</li></ul><p>By default in Seis, all <code>Event</code>s, <code>Station</code>s and <code>Trace</code>s are geographic, and use the <code>Geographic</code> type.  Therefore you do not need to do anything special to work in geographic sense with longitudes, latitudes, and so on.</p><h3 id="Cartesian-geometry"><a class="docs-heading-anchor" href="#Cartesian-geometry">Cartesian geometry</a><a id="Cartesian-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-geometry" title="Permalink"></a></h3><p>However, if you are dealing with data where it makes more sense to consider positions in a Cartesian system, that is straightforward. Use the special constructors for Cartesian objects to create them:</p><ul><li><a href="../function-index/#Seis.CartTrace"><code>CartTrace</code></a> creates a new <code>Trace</code> in an <span>$x, y, z$</span> system.</li><li><a href="../function-index/#Seis.CartStation"><code>CartStation</code></a> creates a Cartesian-referenced <code>Station</code>.</li><li><a href="../function-index/#Seis.CartEvent"><code>CartEvent</code></a> makes a Cartesian-referenced event.</li></ul><p>Where it makes sense, certain accessor functions like <a href="../function-index/#Seis.distance_km"><code>distance_km</code></a> are defined for these types, and these are necessarily different to those for geographic objects.</p><p>For example, <a href="../function-index/#Seis.distance_direct"><code>distance_direct</code></a> will calculate the straight-line distance in m between the event and station when in Cartesian coordinates:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = CartTrace(0, 1e-4, 1000)</code><code class="nohighlight hljs ansi" style="display:block;">Seis.Trace{Float64,Vector{Float64},Seis.Cartesian{Float64}}:
            b: 0.0
        delta: 0.0001
 CartStation{Float64}:
     sta.meta: Seis.SeisDict{Symbol, Any}()
 CartEvent{Float64}:
     evt.meta: Seis.SeisDict{Symbol, Any}()
 Trace:
        picks: 0
         meta:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.sta.x, t.sta.y, t.sta.z = 101, -35, 12</code><code class="nohighlight hljs ansi" style="display:block;">(101, -35, 12)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t.evt.x, t.evt.y, t.evt.z = 12, 14, -100</code><code class="nohighlight hljs ansi" style="display:block;">(12, 14, -100)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; distance_direct(t)</code><code class="nohighlight hljs ansi" style="display:block;">151.21507861321237</code></pre><h3 id="Geometry-type-hierarchy-and-custom-geometry-types"><a class="docs-heading-anchor" href="#Geometry-type-hierarchy-and-custom-geometry-types">Geometry type hierarchy and custom geometry types</a><a id="Geometry-type-hierarchy-and-custom-geometry-types-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-type-hierarchy-and-custom-geometry-types" title="Permalink"></a></h3><p><code>Geographic</code> and <code>Cartesian</code> are subtypes of <a href="../internal-index/#Seis.Position"><code>Seis.Position</code></a>. This means that if you want to define your own coordinate system, you are able to do so by subtyping <code>Seis.Position</code> and you can then write methods taking a <code>Trace{T, V, P} where {T, V, P}</code>, where <code>P</code> is your new type.  These will replace the generic methods allowing special processing to be done in cases where the generic calculations need to be changed, without requiring writing duplicate methods where they do not. An example of a different coordinate system might be when stations have <a href="http://geoweb.princeton.edu/people/simons/earthscopeoceans/">positions which vary in time</a>.</p><h3 id="[Seis.Geographic](@ref)"><a class="docs-heading-anchor" href="#[Seis.Geographic](@ref)"><a href="../internal-index/#Seis.Geographic"><code>Seis.Geographic</code></a></a><a id="[Seis.Geographic](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[Seis.Geographic](@ref)" title="Permalink"></a></h3><h3 id="[Seis.Cartesian](@ref)"><a class="docs-heading-anchor" href="#[Seis.Cartesian](@ref)"><a href="../internal-index/#Seis.Cartesian"><code>Seis.Cartesian</code></a></a><a id="[Seis.Cartesian](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[Seis.Cartesian](@ref)" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../plotting/">Plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 11 October 2024 13:42">Friday 11 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
